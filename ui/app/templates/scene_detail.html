{% extends "base.html" %}

{% block title %}Scene {{ scene.id }} - GeNarrative UI{% endblock %}

{% block content %}
<div class="container">
    {% if scene.project_id %}
    <div class="breadcrumb">
        <a href="/projects">Projects</a> / 
        <a href="/projects/{{ scene.project_id }}">{{ scene.project_id }}</a> / 
        <span>{{ scene.id }}</span>
    </div>
    {% endif %}
    
    <h2>Scene: {{ scene.id }}</h2>

    {# text_*.txt „ÅåÁÑ°„ÅÑÁ©∫„Ç∑„Éº„É≥„Åß„ÇÇ Generate/Save UI „ÇíË°®Á§∫„Åô„Çã„Åü„ÇÅ„ÅÆË°®Á§∫Áî®„É™„Çπ„Éà #}
    {% set display_text_files = scene.text_files if scene.text_files else ['text_' ~ scene.id ~ '.txt'] %}
    
    <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Ç®„É™„Ç¢ÔºöÁîªÂÉèÔºàÂ∑¶Ôºâ„Å®„ÉÜ„Ç≠„Çπ„Éà+Èü≥Ê•ΩÔºàÂè≥Ôºâ -->
    <div class="main-content">
        <!-- Â∑¶ÂÅ¥ÔºöÁîªÂÉè„Çª„ÇØ„Ç∑„Éß„É≥ -->
        {% if scene.image_files %}
        <div class="left-panel">
            <section class="scene-section image-section">
                <h3>Image</h3>
                <div class="section-controls">
                    <input type="file" id="image-upload" accept="image/*" style="display: none;" onchange="uploadImage(this)">
                    <button class="btn btn-upload" onclick="document.getElementById('image-upload').click()">
                        üìÅ Upload Image
                    </button>
                    <button class="btn btn-download" onclick="downloadImage()">
                        üíæ Download Image
                    </button>
                    <button class="btn btn-generate-sis" id="btn-generate-replace" onclick="generateAndReplaceImage()">
                        Genarate
                    </button>
                    <button class="btn btn-save" id="btn-image-save" onclick="saveGeneratedImage()" style="display:none;">
                        üíæ Save
                    </button>
                    <button class="btn btn-cancel" id="btn-image-cancel" onclick="cancelGeneratedImage()" style="display:none;">
                        ‚ùå Cancel
                    </button>
                    
                </div>
                <div class="image-gallery">
                    {% for image_file in scene.image_files %}
                    <div class="image-container">
                        <h4>{{ image_file }}</h4>
                        <img src="/scene/{{ scene.id }}/file/{{ image_file }}" alt="{{ image_file }}" class="scene-image">
                    </div>
                    {% endfor %}
                </div>
                <!-- ÁîªÂÉèÁõ¥‰∏ãÔºöImage Prompt „Çª„ÇØ„Ç∑„Éß„É≥ -->
                <section class="scene-section image-prompt-section" style="margin-top: 10px; border-top: 2px solid #dee2e6; padding-top: 20px;">
                    <h3>üìù Image Prompt (Stable Diffusion)</h3>
                    <div class="prompt-controls" style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                        <button class="btn btn-edit" onclick="togglePromptEdit()">‚úèÔ∏è Edit</button>
                        <button class="btn btn-save" id="btn-prompt-save" onclick="saveImagePrompt()" style="display:none;">üíæ Save</button>
                        <button class="btn btn-cancel" id="btn-prompt-cancel" onclick="cancelPromptEdit()" style="display:none;">‚ùå Cancel</button>
                        <button class="btn btn-download" onclick="copyImagePrompt()">üìã Copy</button>
                    </div>
                    <textarea id="image-prompt-textarea" rows="10" style="width:100%; box-sizing:border-box; background:#f8f9fa; border:1px solid #ced4da; padding:10px; border-radius:6px;" readonly>No image prompt available yet.</textarea>
                </section>
                <!-- Image Prompt „ÅÆ‰∏ãÔºöSD „Ç™„Éó„Ç∑„Éß„É≥ -->
                <div class="sd-options" style="margin: 12px 0 0; padding: 10px; background:#fff; border:1px solid #e5e7eb; border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-width" style="font-weight:600;">W</label>
                            <input id="sd-width" type="number" min="64" step="64" value="512" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-height" style="font-weight:600;">H</label>
                            <input id="sd-height" type="number" min="64" step="64" value="512" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-steps" style="font-weight:600;">Steps</label>
                            <input id="sd-steps" type="number" min="1" step="1" value="20" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-cfg" style="font-weight:600;">CFG</label>
                            <input id="sd-cfg" type="number" min="0" step="0.5" value="7.0" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-sampler" style="font-weight:600;">Sampler</label>
                            <select id="sd-sampler" style="padding:6px;">
                                <option value="Euler a" selected>Euler a</option>
                                <option value="Euler">Euler</option>
                                <option value="DPM++ 2M Karras">DPM++ 2M Karras</option>
                                <option value="DPM++ SDE Karras">DPM++ SDE Karras</option>
                                <option value="DDIM">DDIM</option>
                            </select>
                        </div>
                    </div>
                </div>
                <!-- ÁîªÂÉèÁõ¥‰∏ã„ÅÆText Prompt„ÅØÂâäÈô§„ÄÇText Prompt„ÅØÂè≥ÂÅ¥Text & Speech„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Å´ÈÖçÁΩÆ -->
            </section>
        </div>
        {% else %}
        <div class="left-panel">
            <section class="scene-section image-section">
                <h3>Image</h3>
                <div class="section-controls">
                    <input type="file" id="image-upload" accept="image/*" style="display: none;" onchange="uploadImage(this)">
                    <button class="btn btn-upload" onclick="document.getElementById('image-upload').click()">
                        üìÅ Upload Image
                    </button>
                    <button class="btn btn-generate-sis" id="btn-generate-replace" onclick="generateAndReplaceImage()">
                        Genarate
                    </button>
                    <button class="btn btn-save" id="btn-image-save" onclick="saveGeneratedImage()" style="display:none;">
                        üíæ Save
                    </button>
                    <button class="btn btn-cancel" id="btn-image-cancel" onclick="cancelGeneratedImage()" style="display:none;">
                        ‚ùå Cancel
                    </button>
                    
                </div>
                <div class="no-content">
                    No image available. You can upload an image using the button above.
                </div>
                <!-- ÁîªÂÉèÁõ¥‰∏ãÔºöImage Prompt „Çª„ÇØ„Ç∑„Éß„É≥ -->
                <section class="scene-section image-prompt-section" style="margin-top: 10px; border-top: 2px solid #dee2e6; padding-top: 20px;">
                    <h3>üìù Image Prompt (Stable Diffusion)</h3>
                    <div class="prompt-controls" style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                        <button class="btn btn-edit" onclick="togglePromptEdit()">‚úèÔ∏è Edit</button>
                        <button class="btn btn-save" id="btn-prompt-save" onclick="saveImagePrompt()" style="display:none;">üíæ Save</button>
                        <button class="btn btn-cancel" id="btn-prompt-cancel" onclick="cancelPromptEdit()" style="display:none;">‚ùå Cancel</button>
                        <button class="btn btn-download" onclick="copyImagePrompt()">üìã Copy</button>
                    </div>
                    <textarea id="image-prompt-textarea" rows="10" style="width:100%; box-sizing:border-box; background:#f8f9fa; border:1px solid #ced4da; padding:10px; border-radius:6px;" readonly>No image prompt available yet.</textarea>
                </section>
                <!-- Image Prompt „ÅÆ‰∏ãÔºöSD „Ç™„Éó„Ç∑„Éß„É≥ -->
                <div class="sd-options" style="margin: 12px 0 0; padding: 10px; background:#fff; border:1px solid #e5e7eb; border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-width" style="font-weight:600;">W</label>
                            <input id="sd-width" type="number" min="64" step="64" value="512" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-height" style="font-weight:600;">H</label>
                            <input id="sd-height" type="number" min="64" step="64" value="512" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-steps" style="font-weight:600;">Steps</label>
                            <input id="sd-steps" type="number" min="1" step="1" value="20" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-cfg" style="font-weight:600;">CFG</label>
                            <input id="sd-cfg" type="number" min="0" step="0.5" value="7.0" style="width:88px; padding:6px;">
                        </div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <label for="sd-sampler" style="font-weight:600;">Sampler</label>
                            <select id="sd-sampler" style="padding:6px;">
                                <option value="Euler a" selected>Euler a</option>
                                <option value="Euler">Euler</option>
                                <option value="DPM++ 2M Karras">DPM++ 2M Karras</option>
                                <option value="DPM++ SDE Karras">DPM++ SDE Karras</option>
                                <option value="DDIM">DDIM</option>
                            </select>
                        </div>
                    </div>
                </div>
                <!-- ÁîªÂÉèÁõ¥‰∏ã„ÅÆText Prompt„ÅØÂâäÈô§„ÄÇText Prompt„ÅØÂè≥ÂÅ¥Text & Speech„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Å´ÈÖçÁΩÆ -->
            </section>
        </div>
        {% endif %}
        
        <!-- Âè≥ÂÅ¥Ôºö„ÉÜ„Ç≠„Çπ„Éà+Speech„Å®Èü≥Ê•Ω -->
        <div class="right-panel">
            <!-- Âè≥ÂÅ¥‰∏äÈÉ®Ôºö„ÉÜ„Ç≠„Çπ„Éà+Speech -->
            <section class="scene-section text-section">
                <h3>Text & Speech</h3>
                {% for text_file in display_text_files %}
                <div class="text-container" data-file="{{ text_file }}">
                    <h4>{{ text_file }}</h4>
                    <div class="text-edit-controls">
                        <button class="btn btn-edit" onclick="toggleTextEdit({{ loop.index }})">
                            ‚úèÔ∏è Edit
                        </button>
                        <button class="btn btn-generate-sis" onclick="generateTextFromSIS({{ loop.index }}, '{{ text_file }}')">
                            üöÄ Generate
                        </button>
                        <button class="btn btn-save" id="btn-text-generated-save-{{ loop.index }}" onclick="saveGeneratedTextAndSpeech({{ loop.index }}, '{{ text_file }}')" style="display:none;">
                            üíæ Save
                        </button>
                        <button class="btn btn-cancel" id="btn-text-generated-cancel-{{ loop.index }}" onclick="cancelGeneratedTextAndSpeech({{ loop.index }}, '{{ text_file }}')" style="display:none;">
                            ‚ùå Cancel
                        </button>
                        <button class="btn btn-save" onclick="saveText({{ loop.index }}, '{{ text_file }}')" style="display: none;">
                            üíæ Save
                        </button>
                        <button class="btn btn-cancel" onclick="cancelTextEdit({{ loop.index }})" style="display: none;">
                            ‚ùå Cancel
                        </button>
                    </div>
                    <div class="text-content" id="text-{{ loop.index }}">
                        Ë™≠„ÅøËæº„Åø‰∏≠...
                    </div>
                    <textarea class="text-editor" id="text-editor-{{ loop.index }}" style="display: none;"></textarea>
                    <!-- ÂØæÂøú„Åô„ÇãSpeech„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çå„Å∞ÂÜçÁîü„Éú„Çø„É≥„ÇíË°®Á§∫ -->
                    {% set tts_file = text_file.replace('text_', 'tts_').replace('.txt', '.wav') %}
                    {% if tts_file in scene.tts_files %}
                    <div class="tts-controls">
                        <input type="file" id="tts-upload-{{ loop.index }}" accept="audio/*" style="display: none;" onchange="uploadTTS(this, {{ loop.index }})">
                        <button class="btn btn-upload btn-small" onclick="document.getElementById('tts-upload-{{ loop.index }}').click()">
                            üé§ Upload Speech
                        </button>
                        <button class="btn btn-download btn-small" onclick="downloadTTS('{{ tts_file }}')">
                            üíæ Download Speech
                        </button>
                    </div>
                    <div class="audio-player" id="tts-player-{{ loop.index }}">
                        <div class="player-controls">
                            <button class="play-pause-btn" onclick="togglePlayPause('tts-player-{{ loop.index }}', '/scene/{{ scene.id }}/file/{{ tts_file }}')">
                                <span class="play-icon">‚ñ∂Ô∏è</span>
                                <span class="pause-icon" style="display: none;">‚è∏Ô∏è</span>
                            </button>
                            <span class="file-name">{{ tts_file }}</span>
                            <div class="volume-control">
                                <span class="volume-icon">üîä</span>
                                <input type="range" class="volume-slider" min="0" max="100" value="100" 
                                       onchange="setVolume('tts-player-{{ loop.index }}', this.value)">
                            </div>
                        </div>
                        <div class="progress-container">
                            <div class="time-display">
                                <span class="current-time">0:00</span>
                                <span class="duration">0:00</span>
                            </div>
                            <div class="progress-bar" onclick="seekAudio(event, 'tts-player-{{ loop.index }}')">
                                <div class="progress-fill"></div>
                                <div class="progress-handle"></div>
                            </div>
                        </div>
                        <audio class="audio-element" preload="metadata"></audio>
                    </div>
                    {% else %}
                    <div class="tts-controls">
                        <input type="file" id="tts-upload-{{ loop.index }}" accept="audio/*" style="display: none;" onchange="uploadTTS(this, {{ loop.index }})">
                        <button class="btn btn-upload btn-small" onclick="document.getElementById('tts-upload-{{ loop.index }}').click()">
                            üé§ Upload Speech
                        </button>
                    </div>
                    <div class="no-content-small">
                        No Speech audio available.
                    </div>
                    {% endif %}
                </div>
                {% endfor %}
                <!-- Text Prompt „Çª„ÇØ„Ç∑„Éß„É≥„ÅØÂâäÈô§Ê∏à„Åø -->
                {% if not scene.text_files %}
                <div class="no-content-small" style="margin-top: 10px;">
                    Text file does not exist yet. Use ‚ÄúüöÄ Generate‚Äù or ‚Äúüíæ Save‚Äù to create it.
                </div>
                {% endif %}
            </section>


            
            
            <!-- Âè≥ÂÅ¥‰∏ãÈÉ®ÔºöÈü≥Ê•Ω -->
            {% if scene.music_files %}
            <section class="scene-section music-section">
                <h3>Music</h3>
                <div class="section-controls">
                    <input type="file" id="music-upload" accept="audio/*" style="display: none;" onchange="uploadMusic(this)">
                    <button class="btn btn-upload" onclick="document.getElementById('music-upload').click()">
                        üéµ Upload Music
                    </button>
                    <button class="btn btn-download" onclick="downloadMusic()">
                        üíæ Download Music
                    </button>
                    <button class="btn btn-generate-sis" id="btn-generate-music" onclick="generateSceneMusic()">
                        Generate
                    </button>
                    <button class="btn btn-save" id="btn-music-save" onclick="saveGeneratedMusic()" style="display:none;">
                        üíæ Save
                    </button>
                    <button class="btn btn-cancel" id="btn-music-cancel" onclick="cancelGeneratedMusic()" style="display:none;">
                        ‚ùå Cancel
                    </button>
                </div>
                <div class="music-controls">
                    {% for music_file in scene.music_files %}
                    <div class="audio-player" id="music-player-{{ loop.index }}">
                        <div class="player-controls">
                            <button class="play-pause-btn" onclick="togglePlayPause('music-player-{{ loop.index }}', '/scene/{{ scene.id }}/file/{{ music_file }}')">
                                <span class="play-icon">‚ñ∂Ô∏è</span>
                                <span class="pause-icon" style="display: none;">‚è∏Ô∏è</span>
                            </button>
                            <span class="file-name">{{ music_file }}</span>
                            <div class="volume-control">
                                <span class="volume-icon">üéµ</span>
                                <input type="range" class="volume-slider" min="0" max="100" value="100" 
                                       onchange="setVolume('music-player-{{ loop.index }}', this.value)">
                            </div>
                        </div>
                        <div class="progress-container">
                            <div class="time-display">
                                <span class="current-time">0:00</span>
                                <span class="duration">0:00</span>
                            </div>
                            <div class="progress-bar" onclick="seekAudio(event, 'music-player-{{ loop.index }}')">
                                <div class="progress-fill"></div>
                                <div class="progress-handle"></div>
                            </div>
                        </div>
                        <audio class="audio-element" preload="metadata"></audio>
                    </div>
                    {% endfor %}
                </div>
                <!-- Music Prompt „Çí„Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Å´ÈÖçÁΩÆ -->
                <section class="scene-section music-prompt-section" style="margin-top: 10px; border-top: 2px solid #dee2e6; padding-top: 20px;">
                    <h3>üìù Music Prompt</h3>
                    <div class="prompt-controls" style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                        <button class="btn btn-edit" onclick="toggleMusicPromptEdit()">‚úèÔ∏è Edit</button>
                        <button class="btn btn-save" id="btn-music-prompt-save" onclick="saveMusicPrompt()" style="display:none;">üíæ Save</button>
                        <button class="btn btn-cancel" id="btn-music-prompt-cancel" onclick="cancelMusicPromptEdit()" style="display:none;">‚ùå Cancel</button>
                        <button class="btn btn-download" onclick="copyMusicPrompt()">üìã Copy</button>
                    </div>
                    <textarea id="music-prompt-textarea" rows="6" style="width:100%; box-sizing:border-box; background:#f8f9fa; border:1px solid #ced4da; padding:10px; border-radius:6px;" readonly>No music prompt available yet.</textarea>
                </section>
            </section>
            {% else %}
            <section class="scene-section music-section">
                <h3>Music</h3>
                <div class="section-controls">
                    <input type="file" id="music-upload" accept="audio/*" style="display: none;" onchange="uploadMusic(this)">
                    <button class="btn btn-upload" onclick="document.getElementById('music-upload').click()">
                        üéµ Upload Music
                    </button>
                    <button class="btn btn-generate-sis" id="btn-generate-music" onclick="generateSceneMusic()">
                        Generate
                    </button>
                    <button class="btn btn-save" id="btn-music-save" onclick="saveGeneratedMusic()" style="display:none;">
                        üíæ Save
                    </button>
                    <button class="btn btn-cancel" id="btn-music-cancel" onclick="cancelGeneratedMusic()" style="display:none;">
                        ‚ùå Cancel
                    </button>
                </div>
                <div class="no-content">
                    No music file available. You can upload music using the button above.
                </div>
                <!-- Music Prompt „Çí„Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Å´ÈÖçÁΩÆÔºàÈü≥Ê•ΩÊú™ÁôªÈå≤ÊôÇ„Åß„ÇÇÁ∑®ÈõÜ„Åß„Åç„Çã„Çà„ÅÜ„Å´Ôºâ -->
                <section class="scene-section music-prompt-section" style="margin-top: 10px; border-top: 2px solid #dee2e6; padding-top: 20px;">
                    <h3>üìù Music Prompt</h3>
                    <div class="prompt-controls" style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                        <button class="btn btn-edit" onclick="toggleMusicPromptEdit()">‚úèÔ∏è Edit</button>
                        <button class="btn btn-save" id="btn-music-prompt-save" onclick="saveMusicPrompt()" style="display:none;">üíæ Save</button>
                        <button class="btn btn-cancel" id="btn-music-prompt-cancel" onclick="cancelMusicPromptEdit()" style="display:none;">‚ùå Cancel</button>
                        <button class="btn btn-download" onclick="copyMusicPrompt()">üìã Copy</button>
                    </div>
                    <textarea id="music-prompt-textarea" rows="6" style="width:100%; box-sizing:border-box; background:#f8f9fa; border:1px solid #ced4da; padding:10px; border-radius:6px;" readonly>No music prompt available yet.</textarea>
                </section>
            </section>
            {% endif %}

            
        </div>
    </div>
    

    <!-- ‰∏ÄÁï™‰∏ãÔºöSIS„Çª„ÇØ„Ç∑„Éß„É≥ -->
    {% if scene.sis_files %}
    <section class="scene-section sis-section">
        <h3>SIS (Semantic Interface Structure)</h3>
        <div class="sis-controls-container">
            <div class="sis-edit-main-controls">
                <button class="btn btn-edit" onclick="toggleSISEdit(1)">
                    ‚úèÔ∏è Edit
                </button>
                <button class="btn btn-save" onclick="saveSIS(1, '{{ scene.sis_files[0] if scene.sis_files else '' }}')" style="display: none;">
                    üíæ Save
                </button>
                <button class="btn btn-cancel" onclick="cancelSISEdit(1)" style="display: none;">
                    ‚ùå Cancel
                </button>
                <button class="btn btn-download" onclick="downloadSIS()">
                    üíæ Download
                </button>
                <button class="btn btn-generate-sis" onclick="regeneratePrompts()" id="btn-update-prompts">
                    Update Prompts
                </button>
                <button class="btn btn-save" id="btn-sis-generated-save" onclick="saveGeneratedSIS()" style="display:none;">
                    üíæ Save
                </button>
                <button class="btn btn-cancel" id="btn-sis-generated-cancel" onclick="cancelGeneratedSIS()" style="display:none;">
                    ‚ùå Cancel
                </button>
            </div>
            <div class="sis-generation-controls">
                <button class="btn btn-generate-sis" onclick="generateSISFromImage()">
                    Genarate from Image
                </button>
                <button class="btn btn-generate-sis" onclick="generateSISFromText()">
                    Genarate from Text
                </button>
            </div>
        </div>
        <div class="sis-container" data-file="{{ scene.sis_files[0] }}">
            <h4>{{ scene.sis_files[0] }}</h4>
            <div class="sis-editor">
                <textarea id="sis-1" rows="20" cols="80" placeholder="Ë™≠„ÅøËæº„Åø‰∏≠..." readonly></textarea>
            </div>
        </div>
        
    </section>
    {% else %}
    <section class="scene-section sis-section">
    <h3>SIS (Semantic Interface Structure)</h3>
        <div class="sis-controls-container">
            <div class="sis-generation-controls">
                <button class="btn btn-generate-sis" onclick="generateSISFromImage()">
                    Genarate from Image
                </button>
                <button class="btn btn-generate-sis" onclick="generateSISFromText()">
                    Genarate from Text
                </button>
                <button class="btn btn-generate-sis" onclick="generateSISFromMusic()">
                    üéµ Generate from Music
                </button>
                <button class="btn btn-generate-sis" onclick="regeneratePrompts()" id="btn-update-prompts">
                    Update Prompts
                </button>
                <button class="btn btn-save" id="btn-sis-generated-save" onclick="saveGeneratedSIS()" style="display:none;">
                    üíæ Save
                </button>
                <button class="btn btn-cancel" id="btn-sis-generated-cancel" onclick="cancelGeneratedSIS()" style="display:none;">
                    ‚ùå Cancel
                </button>
            </div>
            <div class="sis-generation-hint">
                <p>üí° No SIS structure found. Generate one using the buttons above from any available content type.</p>
                <p>üîß This will use dummy SIS generation for testing if the full extraction system is not available.</p>
            </div>
        </div>
        <div class="no-content">
            No SIS structure available. You can generate one from existing content using the Generate SIS buttons above.
        </div>
        
    </section>
    {% endif %}
</div>

<style>
.breadcrumb {
    margin-bottom: 20px;
    font-size: 14px;
    color: #666;
}

.breadcrumb a {
    color: #007bff;
    text-decoration: none;
}

.breadcrumb a:hover {
    text-decoration: underline;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

.main-content {
    display: flex;
    gap: 30px;
    margin-bottom: 40px;
    min-height: 600px;
}

.left-panel {
    flex: 0 0 45%;
    max-width: 45%;
}

.right-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.text-section {
    flex: 1;
}

.music-section {
    flex: 0 0 auto;
}

.sis-section {
    margin-top: 40px;
    border-top: 2px solid #dee2e6;
    padding-top: 30px;
}

/* „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú */
@media (max-width: 1024px) {
    .main-content {
        flex-direction: column;
    }
    
    .left-panel {
        flex: none;
        max-width: 100%;
    }
    
    .right-panel {
        flex: none;
    }
}

.scene-section {
    margin-bottom: 12px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 20px;
    background: #f9f9f9;
    /* „Çπ„Éî„Éä„Éº„Ç™„Éº„Éê„Éº„É¨„Ç§„ÅÆÂü∫Ê∫ñ‰ΩçÁΩÆ */
    position: relative;
}

.scene-section h3 {
    margin-top: 0;
    color: #2c3e50;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
}

.sis-container, .text-container, .image-container, .music-item {
    margin-bottom: 20px;
    padding: 15px;
    background: white;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.sis-editor textarea {
    width: 100%;
    min-height: 400px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 14px;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    resize: vertical;
}

.sis-compare-swiper {
    width: 100%;
    overflow: hidden;
}

.sis-compare-swiper .swiper-slide {
    width: 100% !important;
}

.sis-compare-header {
    font-weight: 700;
    margin-bottom: 8px;
}

.sis-compare-textarea {
    width: 100%;
    box-sizing: border-box;
    resize: vertical;
}

.text-content {
    background: #fff;
    padding: 15px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    line-height: 1.6;
    margin-bottom: 10px;
}

.image-gallery {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.image-gallery .image-container {
    margin-bottom: 0;
}

.scene-image {
    max-width: 100%;
    height: auto;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

/* Image compare (Swiper) should not change the original display area size */
.image-compare-swiper {
    width: 100%;
    max-width: 100%;
    overflow: hidden;
}

.image-compare-swiper .swiper-slide {
    display: flex;
}

.image-compare-swiper .image-container {
    width: 100%;
}

.image-compare-swiper .scene-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.audio-controls, .music-controls {
    margin-top: 15px;
}

.music-compare-swiper {
    width: 100%;
    max-width: 100%;
    overflow: hidden;
}

.music-compare-swiper .swiper-slide {
    padding: 8px 0;
    width: 100% !important;
    max-width: 100%;
    box-sizing: border-box;
}

.music-compare-swiper .swiper-wrapper {
    width: 100%;
}

.music-compare-swiper .audio-player {
    max-width: 100%;
    box-sizing: border-box;
}

.music-compare-swiper .player-controls {
    min-width: 0;
}

.music-compare-swiper .file-name {
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.text-compare-swiper,
.tts-compare-swiper {
    width: 100%;
    max-width: 100%;
    overflow: hidden;
}

.text-compare-swiper .swiper-slide,
.tts-compare-swiper .swiper-slide {
    width: 100% !important;
    max-width: 100%;
    box-sizing: border-box;
}

.text-compare-content {
    white-space: pre-wrap;
    word-break: break-word;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin: 0;
}

/* Ensure audio controls remain visible inside Swiper compare (TTS) */
.tts-compare-swiper .play-pause-btn {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Ensure audio controls remain visible inside Swiper compare */
.music-compare-swiper .play-pause-btn {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
}

.music-compare-swiper .play-icon,
.music-compare-swiper .pause-icon {
    display: inline;
    visibility: visible;
    opacity: 1;
}

.audio-player {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
}

.player-controls {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    justify-content: space-between;
}

.volume-control {
    display: flex;
    align-items: center;
    margin-left: auto;
}

.volume-icon {
    margin-right: 8px;
    font-size: 14px;
}

.volume-slider {
    width: 80px;
    height: 4px;
    background: #ddd;
    outline: none;
    border-radius: 2px;
    cursor: pointer;
}

.volume-slider::-webkit-slider-thumb {
    appearance: none;
    width: 16px;
    height: 16px;
    background: #007bff;
    border-radius: 50%;
    cursor: pointer;
}

.volume-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #007bff;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.play-pause-btn {
    background: #28a745;
    color: white;
    border: none;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 15px;
    font-size: 16px;
    transition: background-color 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.play-pause-btn:hover {
    background: #218838;
}

.play-pause-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
}

/* Èü≥Ê•Ω„Éó„É¨„Éº„É§„Éº„ÅØÁï∞„Å™„ÇãËâ≤„Å´„Åô„Çã */
#music-player-1 .play-pause-btn,
#music-player-2 .play-pause-btn,
#music-player-3 .play-pause-btn {
    background: #17a2b8;
}

#music-player-1 .play-pause-btn:hover,
#music-player-2 .play-pause-btn:hover,
#music-player-3 .play-pause-btn:hover {
    background: #138496;
}

#music-player-1 .progress-fill,
#music-player-2 .progress-fill,
#music-player-3 .progress-fill,
#music-player-1 .progress-handle,
#music-player-2 .progress-handle,
#music-player-3 .progress-handle {
    background: #17a2b8;
}

.file-name {
    font-weight: 500;
    color: #495057;
    font-size: 14px;
}

.progress-container {
    width: 100%;
}

.time-display {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: #6c757d;
    margin-bottom: 5px;
}

.progress-bar {
    width: 100%;
    height: 6px;
    background: #e9ecef;
    border-radius: 3px;
    cursor: pointer;
    position: relative;
    margin: 5px 0;
}

.progress-fill {
    height: 100%;
    background: #007bff;
    border-radius: 3px;
    width: 0;
    transition: width 0.1s ease;
}

.progress-handle {
    position: absolute;
    top: -4px;
    left: 0;
    width: 14px;
    height: 14px;
    background: #007bff;
    border-radius: 50%;
    cursor: pointer;
    transform: translateX(-50%);
    opacity: 0;
    transition: opacity 0.2s;
}

.progress-bar:hover .progress-handle {
    opacity: 1;
}

.audio-element {
    display: none;
}

.btn {
    display: inline-block;
    padding: 6px 12px;
    text-decoration: none;
    border: none;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    margin: 5px 5px 5px 0;
    font-size: 12px;
}

.btn-audio {
    background-color: #28a745;
    color: white;
}

.btn-audio:hover {
    background-color: #218838;
}

.btn-secondary {
    background-color: #6c757d;
    color: white;
}

.btn-secondary:hover {
    background-color: #545b62;
}

.navigation {
    margin-top: 40px;
    padding-top: 20px;
    border-top: 1px solid #e0e0e0;
}

h4 {
    margin-top: 0;
    color: #495057;
    font-size: 16px;
}

/* Êñ∞„Åó„ÅèËøΩÂä†„Åô„Çã„Çπ„Çø„Ç§„É´ */
.section-controls {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.text-edit-controls {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.btn-upload {
    background-color: #007bff;
    color: white;
}

.btn-upload:hover {
    background-color: #0056b3;
}

.btn-edit {
    background-color: #007bff;
    color: white;
}

.btn-edit:hover {
    background-color: #0056b3;
}

.btn-generate-sis {
    background-color: #6f42c1;
    color: white;
}

.btn-generate-sis:hover {
    background-color: #5a359a;
}

/* SIS Generation Animation */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideDown {
    from { 
        opacity: 0; 
        transform: translateY(-20px); 
        max-height: 0;
    }
    to { 
        opacity: 1; 
        transform: translateY(0); 
        max-height: 100px;
    }
}

@keyframes slideUp {
    from { 
        opacity: 1; 
        transform: translateY(0); 
        max-height: 100px;
    }
    to { 
        opacity: 0; 
        transform: translateY(-20px); 
        max-height: 0;
    }
}

.sis-generation-progress {
    transition: all 0.3s ease-out;
}

.sis-generation-progress.success {
    animation: pulse 1s ease-in-out;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.02); }
    100% { transform: scale(1); }
}

/* SIS Generation Controls */
.sis-generation-controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
    justify-content: center;
}

.btn-generate-content {
    background-color: #6f42c1;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    white-space: nowrap;
}

.btn-generate-content:hover {
    background-color: #5a359a;
}

/* SIS Controls Container */
.sis-controls-container {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
    align-items: flex-start;
}

.sis-edit-main-controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
}

/* SIS Generation Controls */
.sis-generation-controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
}

/* SIS Edit Controls (removed as they're now in main controls) */
.sis-edit-controls {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.btn-save {
    background-color: #28a745;
    color: white;
}

.btn-save:hover {
    background-color: #218838;
}

.btn-cancel {
    background-color: #dc3545;
    color: white;
}

.btn-cancel:hover {
    background-color: #c82333;
}

.text-editor {
    width: 100%;
    min-height: 150px;
    font-family: inherit;
    font-size: 14px;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 15px;
    resize: vertical;
    line-height: 1.6;
}

.no-content {
    background: #f8f9fa;
    border: 2px dashed #dee2e6;
    padding: 40px 20px;
    text-align: center;
    color: #6c757d;
    border-radius: 8px;
    font-style: italic;
}

.btn-download {
    background-color: #17a2b8;
    color: white;
}

.btn-download:hover {
    background-color: #138496;
}

.tts-controls {
    margin-bottom: 10px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.tts-status {
    font-size: 13px;
    color: #555;
    margin-bottom: 6px;
}

.tts-status.success {
    color: #1e7e34;
}

.tts-status.error {
    color: #c82333;
}

.no-content-small {
    background: #f8f9fa;
    border: 1px dashed #dee2e6;
    padding: 15px 10px;
    text-align: center;
    color: #6c757d;
    border-radius: 4px;
    font-style: italic;
    font-size: 12px;
}

/* „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁî®„ÅÆ„Çπ„Çø„Ç§„É´ */
.upload-progress {
    margin-top: 10px;
    display: none;
}

.progress-bar-upload {
    width: 100%;
    height: 20px;
    background-color: #f1f1f1;
    border-radius: 10px;
    overflow: hidden;
}

.progress-fill-upload {
    height: 100%;
    background-color: #007bff;
    width: 0%;
    transition: width 0.3s ease;
}

.upload-status {
    margin-top: 5px;
    font-size: 12px;
    color: #6c757d;
}

/* ===== „Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Çπ„Éî„Éä„ÉºÔºà„Ç™„Éº„Éê„Éº„É¨„Ç§Ôºâ ===== */
.loading-overlay {
    position: absolute;
    inset: 0;
    background: rgba(255, 255, 255, 0.75);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
    z-index: 50;
}

.loading-overlay .spinner {
    width: 36px;
    height: 36px;
    border: 3px solid #e5e7eb;
    border-top-color: #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-overlay .loading-text {
    font-size: 13px;
    color: #374151;
}

.loading-overlay .loading-text.success { color: #1e7e34; }
.loading-overlay .loading-text.error { color: #c82333; }

@keyframes spin {
    to { transform: rotate(360deg); }
}
</style>

<script>
// „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ„Å´SIS„Å®„ÉÜ„Ç≠„Çπ„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄ
document.addEventListener('DOMContentLoaded', function() {
    // SIS„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
    {% for sis_file in scene.sis_files %}
    loadSISFile('{{ scene.id }}', '{{ sis_file }}', {{ loop.index }});
    {% endfor %}
    
    // „ÉÜ„Ç≠„Çπ„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
    {% for text_file in display_text_files %}
    loadTextFile('{{ scene.id }}', '{{ text_file }}', {{ loop.index }});
    {% endfor %}

    // „Éó„É≠„É≥„Éó„Éà„ÇíÂõ∫ÂÆöÂêç„ÅßË©¶„ÅóË™≠„ÅøÔºàÂ≠òÂú®„Åô„Çå„Å∞Ë™≠„ÅøËæº„ÇÄÔºâ
    loadPromptFile('{{ scene.id }}', `image_{{ scene.id }}_prompt.txt`);
    // Text Prompt „ÅØUI„Åã„ÇâÂâäÈô§Ê∏à„Åø„ÅÆ„Åü„ÇÅ„É≠„Éº„Éâ„Åó„Å™„ÅÑ
    loadMusicPromptFile('{{ scene.id }}', `music_{{ scene.id }}_prompt.txt`);
});

// ===== Ê±éÁî®Ôºö„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Çπ„Éî„Éä„Éº„ÇíË°®Á§∫/ÈùûË°®Á§∫ =====
// target: CSS„Çª„É¨„ÇØ„Çø„Åæ„Åü„ÅØË¶ÅÁ¥†„ÄÇËøî„ÇäÂÄ§„ÅØ‰ΩúÊàê(„Åæ„Åü„ÅØÊó¢Â≠ò)„ÅÆ„Ç™„Éº„Éê„Éº„É¨„Ç§Ë¶ÅÁ¥†
function showLoadingOverlay(target, text) {
    const el = (typeof target === 'string') ? document.querySelector(target) : target;
    if (!el) return null;
    let overlay = el.querySelector(':scope > .loading-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.className = 'loading-overlay';
        overlay.innerHTML = '<div class="spinner"></div><div class="loading-text"></div>';
        el.appendChild(overlay);
    }
    const textEl = overlay.querySelector('.loading-text');
    if (textEl) {
        textEl.classList.remove('success', 'error');
        textEl.textContent = text || 'Processing...';
    }
    return overlay;
}

function hideLoadingOverlay(overlay) {
    if (!overlay) return;
    if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
}

function loadSISFile(sceneId, filename, index) {
    fetch(`/scene/${sceneId}/sis/${filename}`)
        .then(response => response.json())
        .then(data => {
            const textarea = document.getElementById(`sis-${index}`);
            textarea.value = JSON.stringify(data, null, 2);
        })
        .catch(error => {
            console.error('Error loading SIS file:', error);
            document.getElementById(`sis-${index}`).value = '„Ç®„É©„Éº: „Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü';
        });
}

function loadTextFile(sceneId, filename, index) {
    fetch(`/scene/${sceneId}/text/${filename}`)
        .then(async (response) => {
            // text_*.txt „Åå„Åæ„Å†ÁÑ°„ÅÑÂ†¥Âêà„ÅØÁ©∫„Å®„Åó„Å¶Êâ±„ÅÜÔºàGenerate/Save„Åß‰ΩúÊàê„Åï„Çå„ÇãÔºâ
            if (response.status === 404) return '';
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.text();
        })
        .then(data => {
            document.getElementById(`text-${index}`).textContent = data;
        })
        .catch(error => {
            console.error('Error loading text file:', error);
            document.getElementById(`text-${index}`).textContent = '';
        });
}

function loadPromptFile(sceneId, filename) {
    fetch(`/scene/${sceneId}/text/${filename}`)
        .then(response => response.text())
        .then(data => {
            const ta = document.getElementById('image-prompt-textarea');
            if (ta) {
                ta.value = data || 'No image prompt available yet.';
                ta.readOnly = true;
                // ‰øùÂ≠òÊôÇ„ÅÆ„Éá„Éï„Ç©„É´„Éà„Éï„Ç°„Ç§„É´Âêç„Çí‰øùÊåÅ
                ta.dataset.filename = filename;
            }
        })
        .catch(error => {
            console.error('Error loading prompt file:', error);
        });
}

// loadTextPromptFile „ÅØ‰∏çË¶Å„Å´„Å™„Å£„Åü„Åü„ÇÅÂâäÈô§„Åó„Åæ„Åó„Åü

function loadMusicPromptFile(sceneId, filename) {
    // „Ç∑„É≥„Éó„É´Áâà: ÂÆü„Éó„É≠„É≥„Éó„Éà(sis2music_prompt.txt)„Åå„ÅÇ„Çå„Å∞„Åù„Çå„ÇíË°®Á§∫„ÄÅÁÑ°„Åë„Çå„Å∞ÂæìÊù•„Éï„Ç°„Ç§„É´„ÄÇ
    const ta = document.getElementById('music-prompt-textarea');
    if (!ta) return;
    fetch(`/scene/${sceneId}/text/sis2music_prompt.txt`)
        .then(r => r.ok ? r.text() : Promise.reject())
        .then(txt => {
            if (txt && txt.trim()) {
                ta.value = txt.trim();
                ta.readOnly = true;
                const h3 = ta.closest('.music-prompt-section')?.querySelector('h3');
                if (h3) h3.textContent = 'üìù Music Prompt (Actual)';
                return;
            }
        })
        .catch(() => {
            // Fallback to legacy meta prompt file
            fetch(`/scene/${sceneId}/text/${filename}`)
                .then(r => r.ok ? r.text() : Promise.reject())
                .then(txt => {
                    if (txt && txt.trim()) {
                        ta.value = txt.trim();
                        ta.readOnly = true;
                        const h3 = ta.closest('.music-prompt-section')?.querySelector('h3');
                        if (h3) h3.textContent = 'üìù Music Prompt (Meta)';
                    }
                })
                .catch(() => {/* keep default message */});
        });
}

// Êñ∞„Åó„ÅÑÈü≥Â£∞„Éó„É¨„Éº„É§„ÉºÊ©üËÉΩ
function togglePlayPause(playerId, audioUrl) {
    const player = document.getElementById(playerId);
    const audio = player.querySelector('.audio-element');
    const playIcon = player.querySelector('.play-icon');
    const pauseIcon = player.querySelector('.pause-icon');
    const playPauseBtn = player.querySelector('.play-pause-btn');
    const progressFill = player.querySelector('.progress-fill');
    const progressHandle = player.querySelector('.progress-handle');
    const currentTimeSpan = player.querySelector('.current-time');
    const durationSpan = player.querySelector('.duration');

    // ‰ªñ„ÅÆ„Éó„É¨„Éº„É§„Éº„ÇíÂÅúÊ≠¢
    stopAllOtherPlayers(playerId);

    if (audio.paused) {
        // Èü≥Â£∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØË®≠ÂÆö
        if (!audio.src) {
            audio.src = audioUrl;
            audio.addEventListener('loadedmetadata', function() {
                durationSpan.textContent = formatTime(audio.duration);
            });
            audio.addEventListener('timeupdate', function() {
                updateProgress(player);
            });
            audio.addEventListener('ended', function() {
                resetPlayer(player);
            });
        }
        
        playPauseBtn.disabled = true;
        audio.play().then(() => {
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'inline';
            playPauseBtn.disabled = false;
        }).catch(error => {
            console.error('Error playing audio:', error);
            alert('Èü≥Â£∞„ÅÆÂÜçÁîü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            playPauseBtn.disabled = false;
        });
    } else {
        audio.pause();
        playIcon.style.display = 'inline';
        pauseIcon.style.display = 'none';
    }
}

function stopAllOtherPlayers(currentPlayerId) {
    const allPlayers = document.querySelectorAll('.audio-player');
    allPlayers.forEach(player => {
        if (player.id !== currentPlayerId) {
            const audio = player.querySelector('.audio-element');
            if (!audio.paused) {
                audio.pause();
                resetPlayer(player);
            }
        }
    });
}

function resetPlayer(player) {
    const playIcon = player.querySelector('.play-icon');
    const pauseIcon = player.querySelector('.pause-icon');
    const progressFill = player.querySelector('.progress-fill');
    const progressHandle = player.querySelector('.progress-handle');
    const currentTimeSpan = player.querySelector('.current-time');
    
    playIcon.style.display = 'inline';
    pauseIcon.style.display = 'none';
    progressFill.style.width = '0%';
    progressHandle.style.left = '0%';
    currentTimeSpan.textContent = '0:00';
}

function updateProgress(player) {
    const audio = player.querySelector('.audio-element');
    const progressFill = player.querySelector('.progress-fill');
    const progressHandle = player.querySelector('.progress-handle');
    const currentTimeSpan = player.querySelector('.current-time');
    
    if (audio.duration) {
        const progress = (audio.currentTime / audio.duration) * 100;
        progressFill.style.width = progress + '%';
        progressHandle.style.left = progress + '%';
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }
}

function seekAudio(event, playerId) {
    const player = document.getElementById(playerId);
    const audio = player.querySelector('.audio-element');
    const progressBar = player.querySelector('.progress-bar');
    
    if (audio.duration) {
        const rect = progressBar.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const progressBarWidth = rect.width;
        const clickProgress = clickX / progressBarWidth;
        
        audio.currentTime = clickProgress * audio.duration;
    }
}

function formatTime(seconds) {
    if (isNaN(seconds)) return '0:00';
    
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function setVolume(playerId, volume) {
    const player = document.getElementById(playerId);
    const audio = player.querySelector('.audio-element');
    audio.volume = volume / 100;
}

// ÊóßÊ©üËÉΩÔºàÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÊÆã„ÅôÔºâ
function playAudio(audioUrl) {
    console.warn('playAudio function is deprecated. Use togglePlayPause instead.');
}

// „ÉÜ„Ç≠„Çπ„ÉàÁ∑®ÈõÜÊ©üËÉΩ
function toggleTextEdit(index) {
    const textContent = document.getElementById(`text-${index}`);
    const textEditor = document.getElementById(`text-editor-${index}`);
    const container = textContent.closest('.text-container');
    const editBtn = container.querySelector('.btn-edit');
    const saveBtn = container.querySelector('.btn-save');
    const cancelBtn = container.querySelector('.btn-cancel');
    
    // ÁèæÂú®„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
    const currentText = textContent.textContent;
    
    // „Ç®„Éá„Ç£„Çø„Éº„Å´Ë®≠ÂÆö
    textEditor.value = currentText;
    
    // Ë°®Á§∫Âàá„ÇäÊõø„Åà
    textContent.style.display = 'none';
    textEditor.style.display = 'block';
    editBtn.style.display = 'none';
    saveBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'inline-block';
}

function cancelTextEdit(index) {
    const textContent = document.getElementById(`text-${index}`);
    const textEditor = document.getElementById(`text-editor-${index}`);
    const container = textContent.closest('.text-container');
    const editBtn = container.querySelector('.btn-edit');
    const saveBtn = container.querySelector('.btn-save');
    const cancelBtn = container.querySelector('.btn-cancel');
    
    // Ë°®Á§∫Âàá„ÇäÊõø„Åà
    textContent.style.display = 'block';
    textEditor.style.display = 'none';
    editBtn.style.display = 'inline-block';
    saveBtn.style.display = 'none';
    cancelBtn.style.display = 'none';
}

function saveText(index, filename) {
    const textEditor = document.getElementById(`text-editor-${index}`);
    const content = textEditor.value;
    const sceneId = '{{ scene.id }}';
    const container = textEditor.closest('.text-container');
    const saveBtn = container.querySelector('.btn-save');
    
    // ‰øùÂ≠ò„Éú„Çø„É≥„ÇíÁÑ°ÂäπÂåñ
    saveBtn.disabled = true;
    saveBtn.textContent = '‰øùÂ≠ò‰∏≠...';
    
    fetch(`/scene/${sceneId}/save_text`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            content: content,
            filename: filename
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // ÊàêÂäüÊôÇ„ÅÆÂá¶ÁêÜ
            const textContent = document.getElementById(`text-${index}`);
            textContent.textContent = content;
            cancelTextEdit(index);
            regenerateSceneTTS(index, filename, content);
            alert('Text saved successfully!');
        } else {
            alert('Failed to save: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error saving text:', error);
        alert('Error occurred while saving');
    })
    .finally(() => {
        // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
        saveBtn.disabled = false;
        saveBtn.textContent = 'üíæ Save';
    });
}

// ÁîªÂÉè„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊ©üËÉΩ
function uploadImage(input) {
    if (!input.files || !input.files[0]) return;
    
    const file = input.files[0];
    const sceneId = '{{ scene.id }}';
    const formData = new FormData();
    formData.append('file', file);
    
    // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠„ÅÆË°®Á§∫
    const uploadBtn = document.querySelector('.image-section .btn-upload');
    uploadBtn.disabled = true;
    uploadBtn.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...';
    
    fetch(`/scene/${sceneId}/upload_image`, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Image uploaded successfully!');
            // „Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶Êñ∞„Åó„ÅÑÁîªÂÉè„ÇíË°®Á§∫
            window.location.reload();
        } else {
            alert('Upload failed: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error uploading image:', error);
        alert('Error occurred during upload');
    })
    .finally(() => {
        // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'üìÅ Upload Image';
        // „Éï„Ç°„Ç§„É´ÂÖ•Âäõ„Çí„É™„Çª„ÉÉ„Éà
        input.value = '';
    });
}

// Èü≥Ê•Ω„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊ©üËÉΩ
function uploadMusic(input) {
    if (!input.files || !input.files[0]) return;
    
    const file = input.files[0];
    const sceneId = '{{ scene.id }}';
    const formData = new FormData();
    formData.append('file', file);
    
    // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠„ÅÆË°®Á§∫
    const uploadBtn = document.querySelector('.music-section .btn-upload');
    uploadBtn.disabled = true;
    uploadBtn.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...';
    
    fetch(`/scene/${sceneId}/upload_music`, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Music uploaded successfully!');
            // „Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶Êñ∞„Åó„ÅÑÈü≥Ê•Ω„Éï„Ç°„Ç§„É´„ÇíË°®Á§∫
            window.location.reload();
        } else {
            alert('Upload failed: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error uploading music:', error);
        alert('Error occurred during upload');
    })
    .finally(() => {
        // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'üéµ Upload Music';
        // „Éï„Ç°„Ç§„É´ÂÖ•Âäõ„Çí„É™„Çª„ÉÉ„Éà
        input.value = '';
    });
}

// Êñ∞„Åó„ÅÑ„ÉÜ„Ç≠„Çπ„Éà‰ΩúÊàêÊ©üËÉΩ
function createNewText() {
    const content = prompt('Enter new text content:');
    if (content === null || content.trim() === '') {
        return;
    }
    
    const sceneId = '{{ scene.id }}';
    
    fetch(`/scene/${sceneId}/save_text`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            content: content.trim(),
            filename: `text_${sceneId}.txt`
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('New text created successfully!');
            // „Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶Êñ∞„Åó„ÅÑ„ÉÜ„Ç≠„Çπ„Éà„ÇíË°®Á§∫
            window.location.reload();
        } else {
            alert('Creation failed: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error creating text:', error);
        alert('Error occurred during creation');
    });
}

// SIS „Åã„ÇâÊú¨Êñá„ÉÜ„Ç≠„Çπ„Éà„ÇíÁîüÊàê„Åó„Å¶‰øùÂ≠ò„Åó„ÄÅUI„Å´ÂèçÊò†
async function generateTextFromSIS(index, filename) {
    const sceneId = '{{ scene.id }}';
    const container = document.getElementById(`text-${index}`)?.closest('.text-container');
    const genBtn = container ? container.querySelector('.btn-generate-sis') : null;
    const overlay = showLoadingOverlay(container || document.querySelector('.text-section'), 'üìù Generating text...');

    if (genBtn) {
        genBtn.disabled = true;
        genBtn.textContent = 'Generating...';
    }

    showSISGenerationProgress('üìù Generating text from SIS...');
    try {
        const res = await fetch(`/scene/${sceneId}/generate_text`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ output_mode: 'candidate', text_filename: filename })
        });

        if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
        }
        const data = await res.json();
        if (!data.success) {
            throw new Error(data.error || 'Generation failed');
        }

        displayGeneratedTextCandidate(index, filename, data.generated_text || '', data.candidate_filename || '');
        // Generate TTS as candidate from the generated text and show compare
        await generateTTSCandidateForGeneratedText(index, filename, data.generated_text || '');

        showSISGenerationProgress('‚úÖ Text & Speech generated (pending).', 'success');
    } catch (e) {
        console.error('generateTextFromSIS error:', e);
        showSISGenerationProgress(`‚ùå Failed to generate text: ${e.message}`, 'error');
    } finally {
        hideLoadingOverlay(overlay);
        if (genBtn) {
            genBtn.disabled = false;
            genBtn.textContent = 'üöÄ Generate';
        }
    }
}

function escapeHtml(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function setPendingGeneratedText(index, pending) {
    if (!window.__pendingGeneratedText) window.__pendingGeneratedText = {};
    if (pending) window.__pendingGeneratedText[index] = pending;
    else delete window.__pendingGeneratedText[index];

    const saveBtn = document.getElementById(`btn-text-generated-save-${index}`);
    const cancelBtn = document.getElementById(`btn-text-generated-cancel-${index}`);
    const container = document.getElementById(`text-${index}`)?.closest('.text-container');
    const editBtn = container ? container.querySelector('.btn-edit') : null;
    const genBtn = container ? container.querySelector('.btn-generate-sis') : null;
    const hasPending = !!pending;

    if (saveBtn) saveBtn.style.display = hasPending ? 'inline-block' : 'none';
    if (cancelBtn) cancelBtn.style.display = hasPending ? 'inline-block' : 'none';
    if (editBtn) editBtn.disabled = hasPending;
    if (genBtn) genBtn.disabled = hasPending;
}

function showTextCompareSwiper(index, originalText, generatedText, fixedHeightPx) {
    const textEl = document.getElementById(`text-${index}`);
    if (!textEl) return;

    const swiperId = `text-compare-swiper-${index}`;
    textEl.innerHTML = `
        <div class="swiper text-compare-swiper" id="${swiperId}">
            <div class="swiper-wrapper">
                <div class="swiper-slide">
                    <h4>üìù Original</h4>
                    <pre class="text-compare-content">${escapeHtml(originalText || '')}</pre>
                </div>
                <div class="swiper-slide">
                    <h4>üìù Generated</h4>
                    <pre class="text-compare-content">${escapeHtml(generatedText || '')}</pre>
                </div>
            </div>
            <div class="swiper-pagination"></div>
        </div>
    `;

    const el = document.getElementById(swiperId);
    if (el && fixedHeightPx && Number.isFinite(fixedHeightPx) && fixedHeightPx > 0) {
        el.style.height = `${fixedHeightPx}px`;
        el.style.maxHeight = `${fixedHeightPx}px`;
        el.style.overflow = 'hidden';
    }

    try {
        if (window.__textCompareSwipers && window.__textCompareSwipers[index]?.destroy) {
            window.__textCompareSwipers[index].destroy(true, true);
        }
    } catch {}
    if (!window.__textCompareSwipers) window.__textCompareSwipers = {};

    if (typeof Swiper !== 'undefined' && el) {
        window.__textCompareSwipers[index] = new Swiper(el, {
            loop: false,
            initialSlide: 1,
            pagination: { el: el.querySelector('.swiper-pagination'), clickable: true }
        });
    }
}

function displayGeneratedTextCandidate(index, filename, generatedText, candidateFilename) {
    const textEl = document.getElementById(`text-${index}`);
    const container = textEl?.closest('.text-container');
    if (!textEl || !container) return;

    // If editing is active, exit it (candidate compare is view-only)
    const editorEl = document.getElementById(`text-editor-${index}`);
    if (editorEl && editorEl.style.display !== 'none') {
        cancelTextEdit(index);
    }

    const originalText = (textEl.textContent || '').trim() === 'Ë™≠„ÅøËæº„Åø‰∏≠...' ? '' : (textEl.textContent || '');
    const fixedHeight = textEl.getBoundingClientRect().height;

    setPendingGeneratedText(index, {
        filename,
        candidate_filename: candidateFilename,
        original_text: originalText,
        generated_text: generatedText,
        tts_candidate_filename: '',
        tts_target_filename: ''
    });

    showTextCompareSwiper(index, originalText, generatedText, fixedHeight);
}

function getTTSTargetFilenameFromTextFilename(textFilename) {
    const tf = String(textFilename || '');
    if (!tf) return '';
    return tf.replace(/^text_/, 'tts_').replace(/\.txt$/i, '.wav');
}

async function generateTTSCandidateForGeneratedText(index, textFilename, generatedText) {
    const pending = window.__pendingGeneratedText?.[index];
    if (!pending) return;
    const container = document.getElementById(`text-${index}`)?.closest('.text-container');
    if (!container) return;

    const targetTts = getTTSTargetFilenameFromTextFilename(textFilename);
    if (!targetTts) return;

    let response;
    let data = {};
    try {
        response = await fetch(`/scene/{{ scene.id }}/generate_tts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                text_filename: textFilename,
                text_override: generatedText,
                tts_filename: targetTts,
                output_mode: 'candidate'
            })
        });

        try {
            data = await response.json();
        } catch {
            throw new Error('Invalid JSON from TTS server');
        }

        if (!response.ok || data.success === false) {
            throw new Error(data.error || `HTTP ${response.status}`);
        }

        pending.tts_candidate_filename = data.candidate_filename || data.tts_filename || '';
        pending.tts_target_filename = data.target_tts_filename || targetTts;
        setPendingGeneratedText(index, pending);

        showTTSCompareSwiper(index, container, pending.tts_target_filename, pending.tts_candidate_filename);
    } catch (e) {
        console.error('generateTTSCandidateForGeneratedText error:', e);
        // Do not block text compare if speech generation fails
    }
}

function showTTSCompareSwiper(index, container, targetTtsFilename, candidateTtsFilename) {
    if (!container) return;
    const controls = container.querySelector('.tts-controls');
    if (!controls) return;

    const originalNode = controls.nextElementSibling;
    if (!window.__ttsCompareOriginalHTML) window.__ttsCompareOriginalHTML = {};
    if (!window.__ttsCompareOriginalHTML[index]) {
        window.__ttsCompareOriginalHTML[index] = originalNode ? originalNode.outerHTML : '';
    }

    // Remove existing block (audio player or no-content)
    if (originalNode) {
        originalNode.remove();
    }

    const swiperId = `tts-compare-swiper-${index}`;
    const originalUrl = targetTtsFilename ? `/scene/{{ scene.id }}/file/${encodeURIComponent(targetTtsFilename)}` : '';
    const candidateUrl = candidateTtsFilename ? `/scene/{{ scene.id }}/file/${encodeURIComponent(candidateTtsFilename)}` : '';

    const wrapper = document.createElement('div');
    wrapper.innerHTML = `
        <div class="swiper tts-compare-swiper" id="${swiperId}">
            <div class="swiper-wrapper">
                <div class="swiper-slide">
                    <h4>üé§ Original</h4>
                    ${buildAudioPlayerHtml(`tts-player-original-${index}`, targetTtsFilename || 'No Speech', originalUrl)}
                </div>
                <div class="swiper-slide">
                    <h4>üé§ Generated</h4>
                    ${buildAudioPlayerHtml(`tts-player-candidate-${index}`, candidateTtsFilename || 'Generated Speech', candidateUrl)}
                </div>
            </div>
            <div class="swiper-pagination"></div>
        </div>
    `;

    controls.parentNode.insertBefore(wrapper.firstElementChild, controls.nextSibling);

    const el = document.getElementById(swiperId);
    try {
        if (window.__ttsCompareSwipers && window.__ttsCompareSwipers[index]?.destroy) {
            window.__ttsCompareSwipers[index].destroy(true, true);
        }
    } catch {}
    if (!window.__ttsCompareSwipers) window.__ttsCompareSwipers = {};

    if (typeof Swiper !== 'undefined' && el) {
        window.__ttsCompareSwipers[index] = new Swiper(el, {
            loop: false,
            initialSlide: 1,
            pagination: { el: el.querySelector('.swiper-pagination'), clickable: true }
        });
    }
}

function restoreTTSOriginalBlock(index, container) {
    if (!container) return;
    const controls = container.querySelector('.tts-controls');
    if (!controls) return;
    const current = controls.nextElementSibling;
    if (current) current.remove();

    const html = window.__ttsCompareOriginalHTML?.[index] || '';
    if (html) {
        const temp = document.createElement('div');
        temp.innerHTML = html;
        const restored = temp.firstElementChild;
        if (restored) controls.parentNode.insertBefore(restored, controls.nextSibling);
    }
    if (window.__ttsCompareOriginalHTML) delete window.__ttsCompareOriginalHTML[index];
}

async function saveGeneratedTextAndSpeech(index, filename) {
    const pending = window.__pendingGeneratedText?.[index];
    if (!pending) return;

    const saveBtn = document.getElementById(`btn-text-generated-save-${index}`);
    const cancelBtn = document.getElementById(`btn-text-generated-cancel-${index}`);
    if (saveBtn) { saveBtn.disabled = true; saveBtn.textContent = 'Saving...'; }
    if (cancelBtn) cancelBtn.disabled = true;

    try {
        // Save text candidate
        const res = await fetch(`/scene/{{ scene.id }}/save_generated_text`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ candidate_filename: pending.candidate_filename, text_filename: filename })
        });
        let data = {};
        try { data = await res.json(); } catch { throw new Error('Invalid JSON response'); }
        if (!res.ok || !data.success) {
            throw new Error(data.error || `HTTP ${res.status}`);
        }

        // Save TTS candidate if available
        if (pending.tts_candidate_filename && pending.tts_target_filename) {
            const res2 = await fetch(`/scene/{{ scene.id }}/save_generated_tts`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ candidate_filename: pending.tts_candidate_filename, tts_filename: pending.tts_target_filename })
            });
            let data2 = {};
            try { data2 = await res2.json(); } catch { throw new Error('Invalid JSON response'); }
            if (!res2.ok || !data2.success) {
                throw new Error(data2.error || `HTTP ${res2.status}`);
            }
        }

        // Restore normal view with generated text
        const textEl = document.getElementById(`text-${index}`);
        if (textEl) {
            textEl.textContent = pending.generated_text || '';
        }
        const container = textEl?.closest('.text-container');
        if (container) {
            restoreTTSOriginalBlock(index, container);
            if (pending.tts_target_filename) {
                // Update canonical player
                updateTTSPlayer(index, container, pending.tts_target_filename);
            }
        }

        setPendingGeneratedText(index, null);
        showSISGenerationProgress('‚úÖ Text & Speech saved.', 'success');
    } catch (e) {
        console.error('saveGeneratedTextAndSpeech error:', e);
        showSISGenerationProgress(`‚ùå Failed to save: ${e.message}`, 'error');
    } finally {
        if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = 'üíæ Save'; }
        if (cancelBtn) cancelBtn.disabled = false;
    }
}

async function cancelGeneratedTextAndSpeech(index, filename) {
    const pending = window.__pendingGeneratedText?.[index];
    if (!pending) return;
    const cancelBtn = document.getElementById(`btn-text-generated-cancel-${index}`);
    const saveBtn = document.getElementById(`btn-text-generated-save-${index}`);
    if (cancelBtn) { cancelBtn.disabled = true; cancelBtn.textContent = 'Cancelling...'; }
    if (saveBtn) saveBtn.disabled = true;

    try {
        // Discard text candidate
        await fetch(`/scene/{{ scene.id }}/discard_generated_text`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ candidate_filename: pending.candidate_filename })
        });

        // Discard TTS candidate if present
        if (pending.tts_candidate_filename) {
            await fetch(`/scene/{{ scene.id }}/discard_generated_tts`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ candidate_filename: pending.tts_candidate_filename })
            });
        }

        const textEl = document.getElementById(`text-${index}`);
        if (textEl) {
            textEl.textContent = pending.original_text || '';
        }
        const container = textEl?.closest('.text-container');
        if (container) {
            restoreTTSOriginalBlock(index, container);
        }
        setPendingGeneratedText(index, null);
        showSISGenerationProgress('‚úÖ Discarded generated Text & Speech.', 'info');
    } catch (e) {
        console.error('cancelGeneratedTextAndSpeech error:', e);
        showSISGenerationProgress(`‚ùå Failed to discard: ${e.message}`, 'error');
    } finally {
        if (cancelBtn) { cancelBtn.disabled = false; cancelBtn.textContent = '‚ùå Cancel'; }
        if (saveBtn) saveBtn.disabled = false;
    }
}


function ensureTTSStatus(container) {
    if (!container) return null;
    let status = container.querySelector('.tts-status');
    if (!status) {
        status = document.createElement('div');
        status.className = 'tts-status';
        const controls = container.querySelector('.tts-controls');
        if (controls && controls.parentNode) {
            controls.parentNode.insertBefore(status, controls.nextSibling);
        } else {
            container.insertBefore(status, container.firstChild);
        }
    }
    status.classList.remove('success', 'error');
    return status;
}

async function regenerateSceneTTS(index, textFilename, latestText) {
    const container = document.getElementById(`text-${index}`)?.closest('.text-container');
    const status = ensureTTSStatus(container);
    if (!container || !status) return;

    status.textContent = 'üé§ Generating speech from latest text...';
    const overlay = showLoadingOverlay(container, 'üé§ Generating speech...');

    const payload = { text_filename: textFilename };
    if (typeof latestText === 'string' && latestText.trim()) {
        payload.text_override = latestText.trim();
    }

    let response;
    let data = {};
    try {
        response = await fetch(`/scene/{{ scene.id }}/generate_tts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        try {
            data = await response.json();
        } catch (parseError) {
            throw new Error('Invalid JSON from TTS server');
        }

        if (!response.ok || data.success === false) {
            const errMsg = data.error || `HTTP ${response.status}`;
            throw new Error(errMsg);
        }

    updateTTSPlayer(index, container, data.tts_filename);
        status.textContent = '‚úÖ Speech updated.';
        status.classList.add('success');
        setTimeout(() => {
            if (status && status.parentNode) {
                status.remove();
            }
        }, 4000);
    } catch (error) {
        console.error('regenerateSceneTTS error:', error);
        status.textContent = `‚ùå Speech update failed: ${error.message}`;
        status.classList.add('error');
    }
    finally {
        hideLoadingOverlay(overlay);
    }
}

function updateTTSPlayer(index, container, ttsFilename) {
    if (!container) return;

    const remoteUrl = `/scene/{{ scene.id }}/file/${encodeURIComponent(ttsFilename)}`;
    const playerId = `tts-player-${index}`;
    let player = container.querySelector(`#${playerId}`);
    const ttsControls = container.querySelector('.tts-controls');

    // Ensure download button exists and points to the latest file
    if (ttsControls) {
        let downloadBtn = ttsControls.querySelector('.btn-download');
        if (!downloadBtn) {
            downloadBtn = document.createElement('button');
            downloadBtn.className = 'btn btn-download btn-small';
            downloadBtn.textContent = 'üíæ Download Speech';
            ttsControls.appendChild(downloadBtn);
        }
        downloadBtn.onclick = () => downloadTTS(ttsFilename);
    }

    // Remove placeholder if present
    const placeholder = container.querySelector('.no-content-small');
    if (placeholder) {
        placeholder.remove();
    }

    if (!player) {
        player = document.createElement('div');
        player.className = 'audio-player';
        player.id = playerId;
        player.innerHTML = `
            <div class="player-controls">
                <button class="play-pause-btn">
                    <span class="play-icon">‚ñ∂Ô∏è</span>
                    <span class="pause-icon" style="display: none;">‚è∏Ô∏è</span>
                </button>
                <span class="file-name"></span>
                <div class="volume-control">
                    <span class="volume-icon">üîä</span>
                    <input type="range" class="volume-slider" min="0" max="100" value="100">
                </div>
            </div>
            <div class="progress-container">
                <div class="time-display">
                    <span class="current-time">0:00</span>
                    <span class="duration">0:00</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                    <div class="progress-handle"></div>
                </div>
            </div>
            <audio class="audio-element" preload="metadata"></audio>
        `;

        if (ttsControls && ttsControls.parentNode) {
            ttsControls.parentNode.insertBefore(player, ttsControls.nextSibling);
        } else {
            container.appendChild(player);
        }

        const volumeSlider = player.querySelector('.volume-slider');
        if (volumeSlider) {
            volumeSlider.addEventListener('input', function() {
                setVolume(playerId, this.value);
            });
        }

        const progressBar = player.querySelector('.progress-bar');
        if (progressBar) {
            progressBar.addEventListener('click', (event) => seekAudio(event, playerId));
        }
    }

    const fileNameSpan = player.querySelector('.file-name');
    if (fileNameSpan) {
        fileNameSpan.textContent = ttsFilename;
    }

    const playBtn = player.querySelector('.play-pause-btn');
    if (playBtn) {
        playBtn.onclick = () => togglePlayPause(playerId, remoteUrl);
    }

    const progressBar = player.querySelector('.progress-bar');
    if (progressBar) {
        progressBar.onclick = (event) => seekAudio(event, playerId);
    }

    const volumeSlider = player.querySelector('.volume-slider');
    if (volumeSlider) {
        volumeSlider.oninput = function() {
            setVolume(playerId, this.value);
        };
    }

    const audio = player.querySelector('.audio-element');
    if (audio) {
        audio.pause();
        audio.removeAttribute('src');
        audio.load();
    }

    resetPlayer(player);
}

// „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊ©üËÉΩ
function downloadImage() {
    const sceneId = '{{ scene.id }}';
    const imageFiles = [
        {% for image_file in scene.image_files %}'{{ image_file }}'{% if not loop.last %},{% endif %}{% endfor %}
    ];
    
    if (imageFiles.length > 0) {
        const filename = imageFiles[0];
        const downloadUrl = `/scene/${sceneId}/file/${filename}`;
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } else {
        alert('No image available to download');
    }
}

function downloadMusic() {
    const sceneId = '{{ scene.id }}';
    const musicFiles = [
        {% for music_file in scene.music_files %}'{{ music_file }}'{% if not loop.last %},{% endif %}{% endfor %}
    ];
    
    if (musicFiles.length > 0) {
        const filename = musicFiles[0];
        const downloadUrl = `/scene/${sceneId}/file/${filename}`;
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } else {
        alert('No music file available to download');
    }
}

function downloadTTS(filename) {
    const sceneId = '{{ scene.id }}';
    const downloadUrl = `/scene/${sceneId}/file/${filename}`;
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function downloadSIS() {
    const sceneId = '{{ scene.id }}';
    const sisFiles = [{% for sis_file in scene.sis_files %}'{{ sis_file }}'{% if not loop.last %},{% endif %}{% endfor %}];
    
    if (sisFiles.length > 0) {
        const filename = sisFiles[0];
        const downloadUrl = `/scene/${sceneId}/sis/${filename}`;
        
        // SIS„Éï„Ç°„Ç§„É´„ÅØJSON„Å™„ÅÆ„Åß„ÄÅÁèæÂú®„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÅÆÂÜÖÂÆπ„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
        const textarea = document.querySelector('#sis-1');
        if (textarea && textarea.value) {
            const blob = new Blob([textarea.value], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        } else {
            alert('No SIS content available to download');
        }
    } else {
    alert('No SIS file available to download');
    }
}

// TTS„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊ©üËÉΩ
function uploadTTS(input, index) {
    if (!input.files || !input.files[0]) return;
    
    const file = input.files[0];
    const sceneId = '{{ scene.id }}';
    const formData = new FormData();
    formData.append('file', file);
    
    // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠„ÅÆË°®Á§∫
    const uploadBtn = input.parentNode.querySelector('.btn-upload');
    uploadBtn.disabled = true;
    uploadBtn.textContent = 'Uploading...';
    
    fetch(`/scene/${sceneId}/upload_tts`, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('TTS uploaded successfully!');
            // „Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶Êñ∞„Åó„ÅÑTTS„Éï„Ç°„Ç§„É´„ÇíË°®Á§∫
            window.location.reload();
        } else {
            alert('Upload failed: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error uploading TTS:', error);
        alert('Error occurred during upload');
    })
    .finally(() => {
        // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'üé§ Upload Speech';
        // „Éï„Ç°„Ç§„É´ÂÖ•Âäõ„Çí„É™„Çª„ÉÉ„Éà
        input.value = '';
    });
}

// Generate SIS Functions
async function generateSISFromImage() { return generateSIS('image'); }

function generateSISFromText() {
    console.log('üéØ Generate SIS from Text button clicked');
    generateSIS('text');
}

function generateSISFromMusic() {
    console.log('üé∂ Generate SIS from Music button clicked');
    generateSIS('music');
}

// SIS„Åã„ÇâÁîªÂÉèÁîüÊàêÈñ¢Êï∞
async function generateImageFromSIS() {
    console.log('üñºÔ∏è Starting image generation from SIS');
    const imgTarget = document.querySelector('.image-section');
    const overlay = showLoadingOverlay(imgTarget, 'üé® Generating image from SIS...');
    
    try {
        console.log(`üì° Making fetch request to: /scene/{{ scene.id }}/generate_image`);
        
        // Show progress updates on overlay
        let progressInterval = setInterval(() => {
            const msgEl = overlay?.querySelector('.loading-text');
            if (!msgEl) return;
            const msg = msgEl.textContent || '';
            const dots = (msg.match(/\./g) || []).length;
            const newDots = dots >= 6 ? '.' : '.'.repeat(dots + 1);
            msgEl.textContent = `üé® Generating image from SIS${newDots}`;
        }, 3000);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000); // 120s timeout
        const response = await fetch(`/scene/{{ scene.id }}/generate_image`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            signal: controller.signal
        });
        
        clearInterval(progressInterval);
        clearTimeout(timeoutId);
        
        console.log(`üì° Response status: ${response.status}`);
        console.log(`üì° Response status text: ${response.statusText}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        let result;
        try {
            result = await response.json();
        } catch (e) {
            throw new Error('Invalid JSON in response');
        }
        console.log(`üì° Response data:`, result);
        
        if (result.success) {
            let message = `‚úÖ Image generation completed!`;
            if (result.processing_time !== undefined) {
                const processingTime = result.processing_time?.toFixed(1) || 'N/A';
                message += ` ‚è±Ô∏è Processing time: ${processingTime}s`;
            }
            
            if (result.image_info?.image_generated) {
                message += ` üñºÔ∏è Image file created: ${result.image_info.image_filename}`;
                
                // ÁîªÂÉè„ÇíË°®Á§∫
                if (result.image_info.image_url) {
                    console.log(`üñºÔ∏è Displaying image: ${result.image_info.image_url}`);
                    displayGeneratedImage(result.image_info.image_url, result.prompt, { source_path: result.image_info.source_path });
                }
            } else {
                message += ` üìù Image prompt generated (image server not available)`;
            }
            
            showSISGenerationProgress(message, 'success');
            
            // Show generated prompt details
            console.log('Generated Image Prompt:', result.prompt);
            
        } else {
            let errorMessage = `‚ùå Error: ${result.error}`;
            showSISGenerationProgress(errorMessage, 'error');
        }
        
    } catch (error) {
        console.error('Image generation error:', error);
        let errorMessage = '‚ùå Network error occurred during image generation';
        
        if (error.message.includes('404')) {
            errorMessage = '‚ùå No SIS file found. Please generate SIS first.';
        } else if (error.message.includes('500')) {
            errorMessage = '‚ùå Server error during image generation. Check server logs.';
        }
        
        showSISGenerationProgress(errorMessage, 'error');
    } finally {
        try {
            if (typeof progressInterval !== 'undefined' && progressInterval) clearInterval(progressInterval);
        } catch {}
        try { if (typeof timeoutId !== 'undefined') clearTimeout(timeoutId); } catch {}
        hideLoadingOverlay(overlay);
    }
}

// ÁîªÂÉèÁî®„Éó„É≠„É≥„Éó„ÉàÂ∞ÇÁî®„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞„Åô„Çã
function showSISImagePrompt(promptText) {
    const ta = document.getElementById('image-prompt-textarea');
    if (!ta) return;
    ta.value = promptText || '';
    ta.readOnly = true;
    ta.dataset.filename = `image_{{ scene.id }}_prompt.txt`;
    const section = document.querySelector('.image-prompt-section');
    if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        section.style.boxShadow = '0 0 0 2px rgba(40,167,69,0.35)';
        setTimeout(() => { section.style.boxShadow = 'none'; }, 1500);
    }
}

// Text Prompt „Çª„ÇØ„Ç∑„Éß„É≥„ÅØÂâäÈô§Ê∏à„Åø„ÅÆ„Åü„ÇÅ„ÄÅshowSISTextPrompt „ÅØ‰∏çË¶Å„Åß„Åô

// Èü≥Ê•ΩÁî®„Éó„É≠„É≥„Éó„Éà„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
function showSISMusicPrompt(promptText) {
    const ta = document.getElementById('music-prompt-textarea');
    if (!ta) return;
    ta.value = promptText || '';
    ta.readOnly = true;
    // ‰øùÂ≠ò„Åó„Å¶Âç≥Â∫ß„Å´ActualÊâ±„ÅÑ„Å∏
    fetch(`/scene/{{ scene.id }}/save_prompt`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filename: 'sis2music_prompt.txt', content: promptText || '' })
    }).catch(()=>{}).finally(()=> {
        const h3 = ta.closest('.music-prompt-section')?.querySelector('h3');
        if (h3) h3.textContent = 'üìù Music Prompt (Actual)';
    });
    const section = document.querySelector('.music-prompt-section');
    if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'center' });
        section.style.boxShadow = '0 0 0 2px rgba(40,167,69,0.35)';
        setTimeout(() => { section.style.boxShadow = 'none'; }, 1500);
    }
}

// SIS„Åã„ÇâÁîªÂÉè„ÇíÁîüÊàê„Åó„Å¶„Ç∑„Éº„É≥ÁîªÂÉè„ÇíËá™ÂãïÁΩÆ„ÅçÊèõ„Åà„Åô„Çã„Ç∑„É≥„Éó„É´Èñ¢Êï∞
async function generateAndReplaceImage() {
    const btn = document.getElementById('btn-generate-replace');
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'Genarating...';
    }
    const imgSection = document.querySelector('.image-section');
    const overlay = showLoadingOverlay(imgSection, 'üé® Generating image...');

    // Â∞ÇÁî®„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Éó„É≠„É≥„Éó„Éà„Åã„ÇâÁõ¥Êé•SDÁîüÊàê„ÇíÂÆüË°åÔºàUnsloth„Çí‰Ωø„Çè„Å™„ÅÑÔºâ
    const promptText = (document.getElementById('image-prompt-textarea')?.value || '').trim();
    if (!promptText || promptText === 'No image prompt available yet.') {
        showSISGenerationProgress('‚ùå No prompt found. Generate or paste a prompt in the Image Prompt section first.', 'error');
        if (btn) { btn.disabled = false; btn.textContent = 'Genarate'; }
        hideLoadingOverlay(overlay);
        return;
    }

    showSISGenerationProgress('üé® Generating image from prompt via SD...');
    try {
        // SD„Ç™„Éó„Ç∑„Éß„É≥„ÇíÂèéÈõÜÔºà/servers/image„Éá„Éï„Ç©„É´„Éà„Å´Âêà„Çè„Åõ„ÅüÂàùÊúüÂÄ§Ôºâ
        const width = parseInt(document.getElementById('sd-width')?.value || '512', 10);
        const height = parseInt(document.getElementById('sd-height')?.value || '512', 10);
        const steps = parseInt(document.getElementById('sd-steps')?.value || '20', 10);
        const cfg = parseFloat(document.getElementById('sd-cfg')?.value || '7.0');
        const sampler = document.getElementById('sd-sampler')?.value || 'Euler a';

        const response = await fetch(`/scene/{{ scene.id }}/sd_generate_image`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: promptText, width, height, steps, cfg_scale: cfg, sampler_name: sampler })
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();
        if (result.success && (result.candidate_image_url || result.image_url)) {
            // ÁîüÊàêÁîªÂÉè„Çí„ÄåÂÄôË£ú„Äç„Å®„Åó„Å¶ÊØîËºÉË°®Á§∫
            const candidateUrl = result.candidate_image_url || result.image_url;
            displayGeneratedImage(candidateUrl, promptText, { candidate_filename: result.candidate_filename, is_candidate: true });
            showSISGenerationProgress('‚úÖ Image generated from prompt via SD.', 'success');
        } else {
            const reason = result.error || 'Unknown error';
            showSISGenerationProgress(`‚ùå Failed: ${reason}`, 'error');
        }
    } catch (e) {
        console.error(e);
        showSISGenerationProgress(`‚ùå Request failed: ${e.message}`, 'error');
    } finally {
        hideLoadingOverlay(overlay);
        if (btn) {
            btn.disabled = false;
            btn.textContent = 'Genarate';
        }
    }
}

// ÁîªÈù¢ÊúÄ‰∏ãÈÉ®„Å´SDÁî®„Éó„É≠„É≥„Éó„Éà„ÇíË°®Á§∫„Åô„Çã„Éï„ÉÉ„Çø„Éº
function showPromptFooter(promptText) {
    let footer = document.getElementById('prompt-footer');
    if (!footer) {
        footer = document.createElement('div');
        footer.id = 'prompt-footer';
        footer.style.cssText = `
            position: fixed;
            left: 0; right: 0; bottom: 0;
            background: #1f2937;
            color: #fff;
            border-top: 3px solid #28a745;
            max-height: 40vh;
            overflow: auto;
            padding: 12px 16px;
            z-index: 2000;
            box-shadow: 0 -4px 16px rgba(0,0,0,0.25);
        `;
        document.body.appendChild(footer);
    }

    const esc = (s) => String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;');

    footer.innerHTML = `
        <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <strong>üìù Generated SD Prompt</strong>
            <div style="display:flex; gap:8px;">
                <button onclick="navigator.clipboard.writeText(document.querySelector('#prompt-footer pre')?.innerText || '')" class="btn btn-small" style="background:#2563eb; color:#fff;">Copy</button>
                <button onclick="document.getElementById('prompt-footer')?.remove()" class="btn btn-small" style="background:#6b7280; color:#fff;">Close</button>
            </div>
        </div>
        <pre style="white-space:pre-wrap; margin:8px 0 0; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace;">${esc(promptText)}</pre>
    `;

    footer.scrollIntoView({ behavior: 'smooth', block: 'end' });
}

// Generic SIS generation function
async function generateSIS(contentType) {
    console.log(`üöÄ Starting SIS generation for content type: ${contentType}`);
    const sisTarget = document.querySelector('.sis-section') || document.querySelector('.container');
    const overlay = showLoadingOverlay(sisTarget, `üîÑ Generating SIS from ${contentType}...`);
    
    let progressInterval = null;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 120000); // 120s timeout
    
    try {
        console.log(`üì° Making fetch request to: /scene/{{ scene.id }}/generate_sis`);
        
        // Show progress updates on overlay text
        progressInterval = setInterval(() => {
            const msgEl = overlay?.querySelector('.loading-text');
            if (!msgEl) return;
            const msg = msgEl.textContent || '';
            const dots = (msg.match(/\./g) || []).length;
            const newDots = dots >= 6 ? '.' : '.'.repeat(dots + 1);
            msgEl.textContent = `üîÑ Generating SIS from ${contentType}${newDots}`;
        }, 3000);
        
        const response = await fetch(`/scene/{{ scene.id }}/generate_sis`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                content_type: contentType,
                output_mode: 'candidate'
            }),
            signal: controller.signal
        });
        
        if (progressInterval) clearInterval(progressInterval);
        clearTimeout(timeoutId);
        
        console.log(`üì° Response status: ${response.status}`);
        console.log(`üì° Response status text: ${response.statusText}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        let result;
        try {
            result = await response.json();
        } catch (e) {
            throw new Error('Invalid JSON in response');
        }
        console.log(`üì° Response data:`, result);
        
        if (result.success) {
            let message = `‚úÖ SIS generated successfully!`;
            if (result.method) {
                message += ` (Method: ${result.method})`;
            }
            if (result.processing_time !== undefined) {
                const processingTime = result.processing_time?.toFixed(1) || 'N/A';
                message += ` ‚è±Ô∏è Processing time: ${processingTime}s`;
            }

            message += ' üîÑ Prompts remain unchanged until you run Update Prompts.';
            showSISGenerationProgress(message, 'success');

            // Ensure SIS section exists (for scenes without SIS yet)
            const existingTextarea = document.getElementById('sis-1');
            if (!existingTextarea) {
                updateSISSection('', `sis_structure_{{ scene.id }}.json`);
            }

            // Candidate compare (do not overwrite immediately)
            displayGeneratedSISCandidate(result);

            // Show JSON validity info for the returned SIS
            try { showSISJsonValidation(result.json_valid, result.json_parse_error); } catch {}
            
            // Do not auto-enter edit mode; user decides to Save/Cancel.
        } else {
            let errorMessage = `‚ùå Error: ${result.error}`;
            
            // Show debug information if available
            if (result.debug_info) {
                console.log('SIS Generation Debug Info:', result.debug_info);
                errorMessage += '\n\nDebug info has been logged to console (F12).';
            }
            
            // Show suggestions if available
            if (result.suggestion) {
                errorMessage += `\n\nSuggestion: ${result.suggestion}`;
            }
            
            showSISGenerationProgress(errorMessage, 'error');
            
            // Keep error message visible for 10 seconds
            setTimeout(() => {
                const progressDiv = document.querySelector('.sis-generation-progress');
                if (progressDiv && progressDiv.style.backgroundColor === 'rgb(220, 53, 69)') { // red error color
                    progressDiv.style.animation = 'slideUp 0.3s ease-out';
                    setTimeout(() => {
                        if (progressDiv && progressDiv.parentNode) {
                            progressDiv.remove();
                        }
                    }, 300);
                }
            }, 10000);
        }
    } catch (error) {
        try { if (progressInterval) clearInterval(progressInterval); } catch {}
        clearTimeout(timeoutId);
        console.error('Error generating SIS:', error);
        const errorMessage = `‚ùå Network error: ${error.message}`;
        showSISGenerationProgress(errorMessage, 'error');
        
        // Keep error message visible for 10 seconds
        setTimeout(() => {
            const progressDiv = document.querySelector('.sis-generation-progress');
            if (progressDiv && progressDiv.style.backgroundColor === 'rgb(220, 53, 69)') { // red error color
                progressDiv.style.animation = 'slideUp 0.3s ease-out';
                setTimeout(() => {
                    if (progressDiv && progressDiv.parentNode) {
                        progressDiv.remove();
                    }
                }, 300);
            }
        }, 10000);
    } finally {
        try { if (progressInterval) clearInterval(progressInterval); } catch {}
        try { clearTimeout(timeoutId); } catch {}
        hideLoadingOverlay(overlay);
    }
}

function setPendingGeneratedSIS(pending) {
    window.__pendingGeneratedSIS = pending;
    const saveBtn = document.getElementById('btn-sis-generated-save');
    const cancelBtn = document.getElementById('btn-sis-generated-cancel');
    const hasPending = !!pending;
    if (saveBtn) saveBtn.style.display = hasPending ? 'inline-block' : 'none';
    if (cancelBtn) cancelBtn.style.display = hasPending ? 'inline-block' : 'none';
}

function showSISCompareSwiper(originalText, generatedText) {
    const editor = document.querySelector('.sis-section .sis-editor');
    if (!editor) return;

    const textarea = editor.querySelector('#sis-1');
    if (!textarea) return;

    // Persist original UI so we can restore cleanly
    if (!window.__sisCompareOriginalHTML) {
        window.__sisCompareOriginalHTML = textarea.outerHTML;
    }

    textarea.style.display = 'none';

    // Remove existing compare swiper if present
    const existing = editor.querySelector('.sis-compare-swiper');
    if (existing) existing.remove();

    const wrapper = document.createElement('div');
    wrapper.className = 'swiper sis-compare-swiper';
    wrapper.innerHTML = `
        <div class="swiper-wrapper">
            <div class="swiper-slide">
                <div class="sis-compare-header">üß© Original</div>
                <textarea class="sis-compare-textarea" rows="20" readonly></textarea>
            </div>
            <div class="swiper-slide">
                <div class="sis-compare-header">üß© Generated</div>
                <textarea class="sis-compare-textarea" rows="20" readonly></textarea>
            </div>
        </div>
        <div class="swiper-pagination"></div>
    `;

    editor.appendChild(wrapper);

    const areas = wrapper.querySelectorAll('textarea.sis-compare-textarea');
    if (areas[0]) areas[0].value = originalText || '';
    if (areas[1]) areas[1].value = generatedText || '';

    // Keep compare height consistent with SIS editor
    if (textarea) {
        const h = textarea.getBoundingClientRect().height;
        areas.forEach(a => {
            if (h && Number.isFinite(h)) {
                a.style.height = `${Math.max(220, Math.floor(h))}px`;
            }
        });
    }

    try {
        new Swiper(wrapper, {
            initialSlide: 1,
            pagination: { el: wrapper.querySelector('.swiper-pagination'), clickable: true },
            allowTouchMove: true,
        });
    } catch (e) {
        console.warn('Failed to init Swiper for SIS compare:', e);
    }
}

function restoreSISFromCompare() {
    const editor = document.querySelector('.sis-section .sis-editor');
    if (!editor) return;
    const compare = editor.querySelector('.sis-compare-swiper');
    if (compare) compare.remove();

    const textarea = editor.querySelector('#sis-1');
    if (textarea) {
        textarea.style.display = '';
    }
}

function displayGeneratedSISCandidate(result) {
    const original = document.getElementById('sis-1')?.value || '';
    const generated = (typeof result.sis_raw_text === 'string' && result.sis_raw_text) ? result.sis_raw_text : (
        typeof result.sis_data === 'string' ? result.sis_data : (
            typeof result.sis_structure === 'string' ? result.sis_structure : (
                typeof result.sis_data === 'object' ? JSON.stringify(result.sis_data, null, 2) : ''
            )
        )
    );

    setPendingGeneratedSIS({
        candidate_raw_filename: result.candidate_raw_filename,
        candidate_structured_filename: result.candidate_structured_filename,
        generated_text: generated,
        json_valid: !!result.json_valid,
        json_parse_error: result.json_parse_error || null,
    });

    showSISCompareSwiper(original, generated);

    try { showSISJsonValidation(!!result.json_valid, result.json_parse_error); } catch {}
}

async function saveGeneratedSIS() {
    const pending = window.__pendingGeneratedSIS;
    if (!pending) return;
    const saveBtn = document.getElementById('btn-sis-generated-save');
    const cancelBtn = document.getElementById('btn-sis-generated-cancel');
    if (saveBtn) { saveBtn.disabled = true; saveBtn.textContent = 'Saving...'; }
    if (cancelBtn) cancelBtn.disabled = true;

    try {
        const res = await fetch(`/scene/{{ scene.id }}/save_generated_sis`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                candidate_raw_filename: pending.candidate_raw_filename,
                candidate_structured_filename: pending.candidate_structured_filename
            })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.success) {
            throw new Error(data.error || `HTTP ${res.status}`);
        }

        // Update canonical textarea with generated SIS content
        const textarea = document.getElementById('sis-1');
        if (textarea) {
            textarea.value = pending.generated_text || '';
            textarea.readOnly = true;
            textarea.style.backgroundColor = '#f8f9fa';
            textarea.style.border = '1px solid #ced4da';
        }

        restoreSISFromCompare();
        setPendingGeneratedSIS(null);
        showSISGenerationProgress('‚úÖ SIS saved.', 'success');
    } catch (e) {
        console.error('saveGeneratedSIS error:', e);
        showSISGenerationProgress(`‚ùå Failed to save: ${e.message}`, 'error');
    } finally {
        if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = 'üíæ Save'; }
        if (cancelBtn) cancelBtn.disabled = false;
    }
}

async function cancelGeneratedSIS() {
    const pending = window.__pendingGeneratedSIS;
    if (!pending) return;
    const cancelBtn = document.getElementById('btn-sis-generated-cancel');
    const saveBtn = document.getElementById('btn-sis-generated-save');
    if (cancelBtn) { cancelBtn.disabled = true; cancelBtn.textContent = 'Cancelling...'; }
    if (saveBtn) saveBtn.disabled = true;

    try {
        await fetch(`/scene/{{ scene.id }}/discard_generated_sis`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                candidate_raw_filename: pending.candidate_raw_filename,
                candidate_structured_filename: pending.candidate_structured_filename
            })
        });

        restoreSISFromCompare();
        setPendingGeneratedSIS(null);
        showSISGenerationProgress('‚úÖ Discarded generated SIS.', 'success');
    } catch (e) {
        console.error('cancelGeneratedSIS error:', e);
        restoreSISFromCompare();
        setPendingGeneratedSIS(null);
        showSISGenerationProgress(`‚ùå Failed to discard: ${e.message}`, 'error');
    } finally {
        if (cancelBtn) { cancelBtn.disabled = false; cancelBtn.textContent = '‚ùå Cancel'; }
        if (saveBtn) saveBtn.disabled = false;
    }
}

async function regeneratePrompts() {
    const button = document.getElementById('btn-update-prompts');
    if (button) {
        button.disabled = true;
        button.textContent = 'Updating...';
    }
    // ÂêÑ„Éó„É≠„É≥„Éó„ÉàË°®Á§∫È†òÂüü„Å´ÂÄãÂà•„Çπ„Éî„Éä„Éº„ÇíÂá∫„Åô
    const imagePromptSection = document.querySelector('.image-prompt-section');
    const musicPromptSection = document.querySelector('.music-prompt-section');
    const overlays = [];
    if (imagePromptSection) {
        const ov = showLoadingOverlay(imagePromptSection, 'üîÑ Updating image prompt from SIS...');
        if (ov) overlays.push(ov);
    }
    if (musicPromptSection) {
        const ov = showLoadingOverlay(musicPromptSection, 'üîÑ Updating music prompt from SIS...');
        if (ov) overlays.push(ov);
    }

    try {
        const response = await fetch(`/scene/{{ scene.id }}/regenerate_prompts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });

        let result = {};
        try {
            result = await response.json();
        } catch (parseError) {
            throw new Error('Invalid JSON response');
        }

        if (!response.ok || !result.success) {
            throw new Error(result.error || `HTTP ${response.status}`);
        }

        const prompts = result.prompts || {};

        if (prompts.image?.text) {
            showSISImagePrompt(prompts.image.text);
            loadPromptFile('{{ scene.id }}', prompts.image.filename || `image_{{ scene.id }}_prompt.txt`);
        }

        if (prompts.music?.text) {
            showSISMusicPrompt(prompts.music.text);
        }

        if (prompts.text?.text) {
            // Text prompt UI„ÅØÈùûË°®Á§∫„Å†„Åå„Éï„Ç°„Ç§„É´„ÅØÊõ¥Êñ∞„Åó„Å¶„Åä„Åè
            console.log('Text prompt updated.');
        }

        loadMusicPromptFile('{{ scene.id }}', `music_{{ scene.id }}_prompt.txt`);

        let successMessage = '‚úÖ Prompts updated successfully.';
        if (result.warnings && Object.keys(result.warnings).length) {
            const failed = Object.keys(result.warnings).join(', ');
            successMessage += ` ‚ö†Ô∏è Failed to refresh: ${failed}`;
        }

        showSISGenerationProgress(successMessage, result.warnings ? 'info' : 'success');
    } catch (error) {
        console.error('Prompt regeneration failed:', error);
        showSISGenerationProgress(`‚ùå Failed to update prompts: ${error.message}`, 'error');
    } finally {
        overlays.forEach(ov => hideLoadingOverlay(ov));
        if (button) {
            button.disabled = false;
            button.textContent = 'Update Prompts';
        }
    }
}

// Show SIS generation progress
function showSISGenerationProgress(message, type = 'info') {
    // Â∏Ø„ÅÆË°®Á§∫„ÅØÂªÉÊ≠¢„ÄÇÁèæÂú®Ë°®Á§∫‰∏≠„ÅÆ„Ç™„Éº„Éê„Éº„É¨„Ç§„ÅÆÊñáË®Ä„Å†„Åë„ÇíÊõ¥Êñ∞„Åô„Çã„ÄÇ
    document.querySelectorAll('.loading-overlay .loading-text').forEach((el) => {
        el.classList.remove('success', 'error');
        if (type === 'success') el.classList.add('success');
        if (type === 'error') el.classList.add('error');
        el.textContent = message;
    });
}

// Show reaction in SIS section
function showSISReaction(message) {
    const sisSection = document.querySelector('.sis-section');
    if (sisSection) {
        // SIS„Çª„ÇØ„Ç∑„Éß„É≥„Åæ„Åß„Çπ„ÇØ„É≠„Éº„É´
        sisSection.scrollIntoView({ behavior: 'smooth' });
        
        // ‰∏ÄÊôÇÁöÑ„Å´„Éè„Ç§„É©„Ç§„ÉàÂäπÊûú„ÇíËøΩÂä†
        sisSection.style.border = '2px solid #17a2b8';
        sisSection.style.backgroundColor = '#f0f9ff';
        
        // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫ÔºàÊó¢Â≠ò„ÅÆSIS„Éï„Ç°„Ç§„É´„ÅÆ‰∏ä„Å´‰∏ÄÊôÇÁöÑ„Å´Ë°®Á§∫Ôºâ
        const existingMessage = sisSection.querySelector('.sis-generation-message');
        if (existingMessage) {
            existingMessage.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = 'sis-generation-message';
        messageDiv.style.cssText = `
            background: #17a2b8;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        `;
        messageDiv.textContent = message;
        
        // SIS„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆÊúÄÂàù„Å´ÊåøÂÖ•
        const sisHeader = sisSection.querySelector('h2');
        if (sisHeader && sisHeader.nextSibling) {
            sisSection.insertBefore(messageDiv, sisHeader.nextSibling);
        } else {
            sisSection.appendChild(messageDiv);
        }
        
        // 3ÁßíÂæå„Å´„Ç®„Éï„Çß„ÇØ„Éà„ÇíÂâäÈô§
        setTimeout(() => {
            sisSection.style.border = '';
            sisSection.style.backgroundColor = '';
            if (messageDiv) {
                messageDiv.remove();
            }
        }, 3000);
    }
}

// Generate content from SIS
function generateFromSIS(contentType) {
    let message = '';
    let targetSection = '';
    
    switch(contentType) {
        case 'image':
            message = 'Generating Image from SIS...';
            targetSection = '.image-section';
            break;
        case 'text':
            message = 'Generating Text & Speech from SIS...';
            targetSection = '.text-section';
            break;
        case 'music':
            message = 'Generating Music from SIS...';
            targetSection = '.music-section';
            break;
    }
    
    showContentReaction(message, targetSection);
}

// Show reaction in target content section
function showContentReaction(message, targetSectionClass) {
    const targetSection = document.querySelector(targetSectionClass);
    if (targetSection) {
        // „Çø„Éº„Ç≤„ÉÉ„Éà„Çª„ÇØ„Ç∑„Éß„É≥„Åæ„Åß„Çπ„ÇØ„É≠„Éº„É´
        targetSection.scrollIntoView({ behavior: 'smooth' });
        
        // ‰∏ÄÊôÇÁöÑ„Å´„Éè„Ç§„É©„Ç§„ÉàÂäπÊûú„ÇíËøΩÂä†
        targetSection.style.border = '2px solid #28a745';
        targetSection.style.backgroundColor = '#f8fff9';
        
        // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
        const existingMessage = targetSection.querySelector('.content-generation-message');
        if (existingMessage) {
            existingMessage.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = 'content-generation-message';
        messageDiv.style.cssText = `
            background: #28a745;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        `;
        messageDiv.textContent = message;
        
        // „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆÊúÄÂàù„Å´ÊåøÂÖ•
        const sectionHeader = targetSection.querySelector('h3');
        if (sectionHeader && sectionHeader.nextSibling) {
            targetSection.insertBefore(messageDiv, sectionHeader.nextSibling);
        } else {
            targetSection.appendChild(messageDiv);
        }
        
        // 3ÁßíÂæå„Å´„Ç®„Éï„Çß„ÇØ„Éà„ÇíÂâäÈô§
        setTimeout(() => {
            targetSection.style.border = '';
            targetSection.style.backgroundColor = '';
            if (messageDiv) {
                messageDiv.remove();
            }
        }, 3000);
    }
}

// Update SIS section with new content
function updateSISSection(sisContent, fileName) {
    // Normalize content to string (object -> JSON, string -> as-is)
    let formattedContent = typeof sisContent === 'object' ? JSON.stringify(sisContent, null, 2) : String(sisContent || '');

    // Find existing SIS section if present
    let sisSection = document.querySelector('.sis-section');

    if (sisSection) {
        // Ensure Update Prompts button exists even if the template predates the new control
        const editControls = sisSection.querySelector('.sis-edit-main-controls');
        if (editControls && !editControls.querySelector('#btn-update-prompts')) {
            const updateBtn = document.createElement('button');
            updateBtn.className = 'btn btn-generate-sis';
            updateBtn.id = 'btn-update-prompts';
            updateBtn.textContent = 'Update Prompts';
            updateBtn.onclick = () => regeneratePrompts();
            editControls.appendChild(updateBtn);
        }

    // Do NOT replace existing buttons/controls; only update the SIS content area
        let sisContainer = sisSection.querySelector('.sis-container');
        if (!sisContainer) {
            // Create container minimally without touching generation buttons
            sisContainer = document.createElement('div');
            sisContainer.className = 'sis-container';
            sisSection.appendChild(sisContainer);
        }

        // Update dataset filename and title
        sisContainer.setAttribute('data-file', fileName);
        let titleEl = sisContainer.querySelector('h4');
        if (!titleEl) {
            titleEl = document.createElement('h4');
            sisContainer.prepend(titleEl);
        }
    titleEl.textContent = fileName;

        // Ensure editor wrapper exists
        let editorWrapper = sisContainer.querySelector('.sis-editor');
        if (!editorWrapper) {
            editorWrapper = document.createElement('div');
            editorWrapper.className = 'sis-editor';
            sisContainer.appendChild(editorWrapper);
        }

        // Ensure textarea exists and update content
        let textarea = editorWrapper.querySelector('#sis-1');
        if (!textarea) {
            textarea = document.createElement('textarea');
            textarea.id = 'sis-1';
            textarea.rows = 20;
            textarea.cols = 80;
            textarea.readOnly = true;
            editorWrapper.appendChild(textarea);
        }
    textarea.readOnly = true;
    textarea.value = formattedContent;

    } else {
    // Create fresh SIS section while keeping the original button set (Generate from Image/Text)
        sisSection = document.createElement('section');
        sisSection.className = 'scene-section sis-section';
        sisSection.style.cssText = `
            margin-top: 40px;
            border-top: 2px solid #dee2e6;
            padding-top: 30px;
        `;

        sisSection.innerHTML = `
            <h3>SIS (Semantic Interface Structure)</h3>
            <div class="sis-controls-container">
                <div class="sis-edit-main-controls">
                    <button class="btn btn-edit" onclick="toggleSISEdit(1)">‚úèÔ∏è Edit</button>
                    <button class="btn btn-save" onclick="saveSIS(1, '${fileName}')" style="display: none;">üíæ Save</button>
                    <button class="btn btn-cancel" onclick="cancelSISEdit(1)" style="display: none;">‚ùå Cancel</button>
                    <button class="btn btn-download" onclick="downloadSIS()">üíæ Download</button>
                    <button class="btn btn-generate-sis" onclick="regeneratePrompts()" id="btn-update-prompts">Update Prompts</button>
                </div>
                <div class="sis-generation-controls">
                    <button class="btn btn-generate-sis" onclick="generateSISFromImage()">Genarate from Image</button>
                    <button class="btn btn-generate-sis" onclick="generateSISFromText()">Genarate from Text</button>
                </div>
            </div>
            <div class="sis-container" data-file="${fileName}">
                <h4>${fileName}</h4>
                <div class="sis-editor">
                    <textarea id="sis-1" rows="20" cols="80" readonly>${formattedContent}</textarea>
                </div>
            </div>
        `;

        // Insert before navigation
        const navigation = document.querySelector('.navigation');
        if (navigation && navigation.parentNode) {
            navigation.parentNode.insertBefore(sisSection, navigation);
        } else {
            const container = document.querySelector('.container');
            if (container) container.appendChild(sisSection);
        }
    }

    // Bring attention to the updated SIS section without altering buttons
    sisSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    sisSection.style.border = '2px solid #28a745';
    sisSection.style.backgroundColor = '#f8fff9';
    setTimeout(() => {
        sisSection.style.border = '';
        sisSection.style.backgroundColor = '';
    }, 3000);
}

// Show JSON validity / parse error banner near SIS
function showSISJsonValidation(jsonValid, parseError) {
    const sisSection = document.querySelector('.sis-section');
    if (!sisSection) return;

    // Remove existing banner
    const old = sisSection.querySelector('.sis-json-warning');
    if (old) old.remove();

    const banner = document.createElement('div');
    banner.className = 'sis-json-warning';
    banner.style.cssText = `
        margin: 10px 0 0; padding: 10px 12px; border-radius: 6px;
        font-size: 14px; line-height: 1.5;
    `;

    if (jsonValid) {
        banner.style.background = '#ecfdf5';
        banner.style.border = '1px solid #10b981';
        banner.style.color = '#065f46';
        banner.textContent = '‚úÖ This SIS can be interpreted as valid JSON. You can edit it as needed and save it.';
    } else {
        banner.style.background = '#fff7ed';
        banner.style.border = '1px solid #f97316';
        banner.style.color = '#7c2d12';
        banner.innerHTML = `‚ö†Ô∏è „Åì„ÅÆSIS„ÅØÁèæÂú®JSON„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÁ∑®ÈõÜ„ÅØÂèØËÉΩ„Åß„Åô„Åå„ÄÅJSON„Å®„Åó„Å¶‰øùÂ≠ò„Åô„Çã„Å´„ÅØ‰øÆÊ≠£„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ` +
            (parseError ? `<div style="margin-top:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; white-space:pre-wrap;">„Ç®„É©„Éº: ${escapeHtml(parseError)}</div>` : '');
    }

    const container = sisSection.querySelector('.sis-controls-container');
    if (container) {
        container.insertAdjacentElement('afterend', banner);
    } else {
        sisSection.prepend(banner);
    }
}

function escapeHtml(s) {
    return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;');
}

// SIS Edit Functions
function toggleSISEdit(index) {
    const container = document.querySelector('.sis-edit-main-controls');
    const textarea = document.querySelector(`#sis-${index}`);
    const editBtn = container.querySelector('.btn-edit');
    const saveBtn = container.querySelector('.btn-save');
    const cancelBtn = container.querySelector('.btn-cancel');
    
    // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÇíÁ∑®ÈõÜÂèØËÉΩ„Å´„Åô„Çã
    textarea.readOnly = false;
    textarea.style.backgroundColor = '#fff';
    textarea.style.border = '2px solid #007bff';
    textarea.focus();
    
    // ÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Çí‰øùÂ≠ò
    textarea.dataset.originalText = textarea.value;
    
    // „Éú„Çø„É≥„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà
    editBtn.style.display = 'none';
    saveBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'inline-block';
}

function saveSIS(index, fileName) {
    const container = document.querySelector('.sis-edit-main-controls');
    const textarea = document.querySelector(`#sis-${index}`);
    const editBtn = container.querySelector('.btn-edit');
    const saveBtn = container.querySelector('.btn-save');
    const cancelBtn = container.querySelector('.btn-cancel');
    
    const sceneId = '{{ scene.id }}';
    const content = textarea.value;
    
    // „Éú„Çø„É≥„ÇíÁÑ°ÂäπÂåñ
    saveBtn.disabled = true;
    saveBtn.textContent = 'Saving...';
    
    // SIS„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò
    fetch(`/scene/${sceneId}/save_sis`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            filename: fileName,
            content: content
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÇíË™≠„ÅøÂèñ„ÇäÂ∞ÇÁî®„Å´Êàª„Åô
            textarea.readOnly = true;
            textarea.style.backgroundColor = '#f8f9fa';
            textarea.style.border = '1px solid #ced4da';
            
            // ÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊõ¥Êñ∞
            delete textarea.dataset.originalText;
            
            // „Éú„Çø„É≥„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            
            alert('SIS saved successfully!');
        } else {
            alert('Failed to save SIS: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error saving SIS:', error);
        alert('Error occurred while saving SIS');
    })
    .finally(() => {
        // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
        saveBtn.disabled = false;
        saveBtn.textContent = 'üíæ Save';
    });
}

function cancelSISEdit(index) {
    const container = document.querySelector('.sis-edit-main-controls');
    const textarea = document.querySelector(`#sis-${index}`);
    const editBtn = container.querySelector('.btn-edit');
    const saveBtn = container.querySelector('.btn-save');
    const cancelBtn = container.querySelector('.btn-cancel');
    
    // ÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Å´Êàª„Åô
    if (textarea.dataset.originalText !== undefined) {
        textarea.value = textarea.dataset.originalText;
        delete textarea.dataset.originalText;
    }
    
    // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÇíË™≠„ÅøÂèñ„ÇäÂ∞ÇÁî®„Å´Êàª„Åô
    textarea.readOnly = true;
    textarea.style.backgroundColor = '#f8f9fa';
    textarea.style.border = '1px solid #ced4da';
    
    // „Éú„Çø„É≥„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà
    editBtn.style.display = 'inline-block';
    saveBtn.style.display = 'none';
    cancelBtn.style.display = 'none';
}

// Image Prompt Á∑®ÈõÜÊ©üËÉΩ
function togglePromptEdit() {
    const ta = document.getElementById('image-prompt-textarea');
    const saveBtn = document.getElementById('btn-prompt-save');
    const cancelBtn = document.getElementById('btn-prompt-cancel');
    const editBtn = document.querySelector('.image-prompt-section .btn-edit');
    if (!ta || !saveBtn || !cancelBtn || !editBtn) return;

    ta.readOnly = false;
    ta.style.backgroundColor = '#fff';
    ta.style.border = '2px solid #007bff';
    ta.focus();
    ta.dataset.originalText = ta.value;
    editBtn.style.display = 'none';
    saveBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'inline-block';
}

function saveImagePrompt() {
    const ta = document.getElementById('image-prompt-textarea');
    const saveBtn = document.getElementById('btn-prompt-save');
    const cancelBtn = document.getElementById('btn-prompt-cancel');
    const editBtn = document.querySelector('.image-prompt-section .btn-edit');
    if (!ta || !saveBtn || !cancelBtn || !editBtn) return;

    const sceneId = '{{ scene.id }}';
    const content = ta.value;
    const filename = ta.dataset.filename || `image_${sceneId}_prompt.txt`;

    saveBtn.disabled = true;
    saveBtn.textContent = 'Saving...';

    fetch(`/scene/${sceneId}/save_prompt`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filename, content })
    })
    .then(res => res.json())
    .then(data => {
        if (data.success) {
            ta.readOnly = true;
            ta.style.backgroundColor = '#f8f9fa';
            ta.style.border = '1px solid #ced4da';
            delete ta.dataset.originalText;
            ta.dataset.filename = data.filename || filename;
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            alert('Prompt saved successfully!');
        } else {
            alert('Failed to save prompt: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(err => {
        console.error('Error saving prompt:', err);
        alert('Error occurred while saving prompt');
    })
    .finally(() => {
        saveBtn.disabled = false;
        saveBtn.textContent = 'üíæ Save';
    });
}

function cancelPromptEdit() {
    const ta = document.getElementById('image-prompt-textarea');
    const saveBtn = document.getElementById('btn-prompt-save');
    const cancelBtn = document.getElementById('btn-prompt-cancel');
    const editBtn = document.querySelector('.image-prompt-section .btn-edit');
    if (!ta || !saveBtn || !cancelBtn || !editBtn) return;

    if (ta.dataset.originalText !== undefined) {
        ta.value = ta.dataset.originalText;
        delete ta.dataset.originalText;
    }
    ta.readOnly = true;
    ta.style.backgroundColor = '#f8f9fa';
    ta.style.border = '1px solid #ced4da';
    editBtn.style.display = 'inline-block';
    saveBtn.style.display = 'none';
    cancelBtn.style.display = 'none';
}

function copyImagePrompt() {
    const ta = document.getElementById('image-prompt-textarea');
    if (!ta) return;
    navigator.clipboard.writeText(ta.value || '');
}

// Text Prompt Á∑®ÈõÜÁ≥ª„ÅØÂâäÈô§„Åó„Åæ„Åó„Åü

// Music Prompt Á∑®ÈõÜÁ≥ª
function toggleMusicPromptEdit() {
    const ta = document.getElementById('music-prompt-textarea');
    const saveBtn = document.getElementById('btn-music-prompt-save');
    const cancelBtn = document.getElementById('btn-music-prompt-cancel');
    const editBtn = document.querySelector('.music-prompt-section .btn-edit');
    if (!ta || !saveBtn || !cancelBtn || !editBtn) return;

    // „Åô„Åß„Å´Á∑®ÈõÜ‰∏≠„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºàSave/Cancel„ÅßÁµÇ‰∫Ü„Åï„Åõ„ÇãÔºâ
    if (!ta.readOnly) {
        ta.focus();
        return;
    }

    // Á∑®ÈõÜ„É¢„Éº„Éâ„Å∏ÂÖ•„Çã
    ta.readOnly = false;
    ta.style.backgroundColor = '#fff';
    ta.style.border = '2px solid #007bff';
    ta.dataset.originalText = ta.value;
    editBtn.style.display = 'none';
    saveBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'inline-block';
    ta.focus();
}

function saveMusicPrompt() {
    const ta = document.getElementById('music-prompt-textarea');
    if (!ta) return;
    // ÁîüÊàê„Éú„Çø„É≥„Çí‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ„Åó„ÄÅ‰øùÂ≠ò‰∏≠„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã
    const genBtn = document.getElementById('btn-generate-music');
    if (genBtn) genBtn.disabled = true;
    window.__musicPromptSaving = true;
    fetch(`/scene/{{ scene.id }}/save_prompt`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        // ÂÆü„Éó„É≠„É≥„Éó„Éà„Å®„Åó„Å¶‰øùÂ≠ò
        body: JSON.stringify({ content: ta.value, filename: `sis2music_prompt.txt` })
    }).then(r => r.json()).then(res => {
        if (res.success) {
            showSISGenerationProgress('üíæ Music prompt saved.', 'success');
            ta.readOnly = true;
            ta.style.backgroundColor = '#f8f9fa';
            ta.style.border = '1px solid #ced4da';
            delete ta.dataset.originalText;
            document.getElementById('btn-music-prompt-save').style.display = 'none';
            document.getElementById('btn-music-prompt-cancel').style.display = 'none';
            const editBtn = document.querySelector('.music-prompt-section .btn-edit');
            if (editBtn) editBtn.style.display = 'inline-block';
            // „Éò„ÉÉ„ÉÄË°®Ë®ò„ÇíActual„Å´Êõ¥Êñ∞
            const h3 = ta.closest('.music-prompt-section')?.querySelector('h3');
            if (h3) h3.textContent = 'üìù Music Prompt (Actual)';
        } else {
            showSISGenerationProgress('‚ùå Failed to save music prompt.', 'error');
        }
    }).catch(() => showSISGenerationProgress('‚ùå Failed to save music prompt.', 'error'))
    .finally(() => {
        window.__musicPromptSaving = false;
        if (genBtn) genBtn.disabled = false;
    });
}

function cancelMusicPromptEdit() {
    const ta = document.getElementById('music-prompt-textarea');
    if (!ta) return;
    // ÂÖÉ„Å´Êàª„Åô
    if (ta.dataset.originalText !== undefined) {
        ta.value = ta.dataset.originalText;
        delete ta.dataset.originalText;
    }
    ta.readOnly = true;
    ta.style.backgroundColor = '#f8f9fa';
    ta.style.border = '1px solid #ced4da';
    document.getElementById('btn-music-prompt-save').style.display = 'none';
    document.getElementById('btn-music-prompt-cancel').style.display = 'none';
    const editBtn = document.querySelector('.music-prompt-section .btn-edit');
    if (editBtn) editBtn.style.display = 'inline-block';
}

function copyMusicPrompt() {
    const ta = document.getElementById('music-prompt-textarea');
    if (!ta) return;
    navigator.clipboard.writeText(ta.value || '');
    showSISGenerationProgress('üìã Music prompt copied to clipboard.', 'success');
}

// ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
function getCacheBustedUrl(url) {
    if (!url) return '';
    return url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
}

function getOriginalImageUrlForCompare() {
    // Êó¢„Å´ÊØîËºÉUI„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ original „Çπ„É©„Ç§„Éâ„Åã„ÇâÊãæ„ÅÜ
    const originalEl = document.querySelector('.image-compare-swiper img[data-role="original"]');
    if (originalEl?.getAttribute('src')) return originalEl.getAttribute('src');

    // ÈÄöÂ∏∏Ë°®Á§∫„ÅÆÂ†¥Âêà„ÅØÊúÄÂàù„ÅÆÁîªÂÉè„ÇíÊãæ„ÅÜ
    const img = document.querySelector('.image-gallery .scene-image');
    return img?.getAttribute('src') || '';
}

function getOriginalImageDisplayHeightForCompare() {
    // „Åæ„Åö„ÅØÊó¢Â≠òÁîªÂÉè„ÅÆË°®Á§∫È´ò„Åï„ÇíÂÑ™ÂÖà
    const img = document.querySelector('.image-gallery .scene-image');
    const h1 = img?.getBoundingClientRect?.().height;
    if (h1 && h1 > 0) return Math.round(h1);

    // Ê¨°„Å´„ÇÆ„É£„É©„É™„ÉºÈ†òÂüü„ÅÆÈ´ò„Åï
    const gallery = document.querySelector('.image-gallery');
    const h2 = gallery?.getBoundingClientRect?.().height;
    if (h2 && h2 > 0) return Math.round(h2);

    return null;
}

function showImageCompareSwiper(originalUrl, generatedUrl, fixedHeightPx) {
    const imageSection = document.querySelector('.image-section');
    if (!imageSection) return;

    // no-content „Åå„ÅÇ„Çå„Å∞Ê∂à„Åó„Å¶ gallery „Çí‰Ωú„Çã
    const noContentArea = imageSection.querySelector('.no-content');
    if (noContentArea) noContentArea.remove();

    let imageGallery = imageSection.querySelector('.image-gallery');
    if (!imageGallery) {
        imageGallery = document.createElement('div');
        imageGallery.className = 'image-gallery';
        imageSection.appendChild(imageGallery);
    }

    const orig = originalUrl ? getCacheBustedUrl(originalUrl) : '';
    const gen = getCacheBustedUrl(generatedUrl);

    imageGallery.innerHTML = `
        <div class="swiper image-compare-swiper">
            <div class="swiper-wrapper">
                <div class="swiper-slide">
                    <div class="image-container">
                        <h4>üñºÔ∏è Original</h4>
                        ${orig ? `<img src="${orig}" data-role="original" alt="Original Image" class="scene-image" onclick="window.open('${orig}', '_blank')">` : `<div class="no-content-small">No original image.</div>`}
                    </div>
                </div>
                <div class="swiper-slide">
                    <div class="image-container">
                        <h4>üé® Generated</h4>
                        <img src="${gen}" data-role="generated" alt="Generated Image" class="scene-image" onclick="window.open('${gen}', '_blank')">
                    </div>
                </div>
            </div>
            <div class="swiper-pagination"></div>
            <div class="swiper-button-next"></div>
            <div class="swiper-button-prev"></div>
        </div>
    `;

    // Swiper ÂàùÊúüÂåñÔºàÊó¢Â≠ò„Åå„ÅÇ„Çå„Å∞Á†¥Ê£ÑÔºâ
    try {
        if (window.__imageCompareSwiper && typeof window.__imageCompareSwiper.destroy === 'function') {
            window.__imageCompareSwiper.destroy(true, true);
        }
    } catch {}

    const el = imageGallery.querySelector('.image-compare-swiper');
    if (!el) return;

    // ÂÖÉ„ÅÆË°®Á§∫È†òÂüü„ÅÆÈ´ò„Åï„ÇíÁ∂≠ÊåÅ
    if (fixedHeightPx && Number.isFinite(fixedHeightPx) && fixedHeightPx > 0) {
        el.style.height = `${fixedHeightPx}px`;
        el.style.maxHeight = `${fixedHeightPx}px`;
    }

    window.__imageCompareSwiper = new Swiper(el, {
        loop: false,
        // ÂàùÊúüË°®Á§∫„ÅØÁîüÊàêÁîªÂÉèÔºà2ÊûöÁõÆÔºâ
        initialSlide: 1,
        pagination: {
            el: el.querySelector('.swiper-pagination'),
            clickable: true,
        },
        navigation: {
            nextEl: el.querySelector('.swiper-button-next'),
            prevEl: el.querySelector('.swiper-button-prev'),
        },
    });

    const firstContainer = imageGallery.querySelector('.image-container');
    if (firstContainer) firstContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function setPendingGeneratedImage(meta) {
    window.__pendingGeneratedImage = meta || null;
    const saveBtn = document.getElementById('btn-image-save');
    const cancelBtn = document.getElementById('btn-image-cancel');
    if (saveBtn) {
        saveBtn.style.display = window.__pendingGeneratedImage ? 'inline-block' : 'none';
        saveBtn.disabled = false;
    }
    if (cancelBtn) {
        cancelBtn.style.display = window.__pendingGeneratedImage ? 'inline-block' : 'none';
        cancelBtn.disabled = false;
    }
}

// ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„Çí„ÄåÊØîËºÉË°®Á§∫„Äç„Åô„ÇãÈñ¢Êï∞ÔºàGenerateÊôÇ„Å´Âëº„Å∞„Çå„ÇãÔºâ
function displayGeneratedImage(imageUrl, prompt, meta) {
    console.log(`üñºÔ∏è Showing compare swiper. generated=${imageUrl}`);
    const originalUrl = getOriginalImageUrlForCompare();
    const originalHeight = getOriginalImageDisplayHeightForCompare();

    // SaveÁ¢∫ÂÆö„ÅÆ„Åü„ÇÅ„ÅÆ„É°„ÇøÊÉÖÂ†±„Çí‰øùÊåÅ
    const pending = {
        prompt: prompt || '',
        generated_url: imageUrl,
        candidate_filename: meta?.candidate_filename || '',
        source_path: meta?.source_path || '',
    };
    setPendingGeneratedImage(pending);

    showImageCompareSwiper(originalUrl, imageUrl, originalHeight);
}

async function saveGeneratedImage() {
    const sceneId = '{{ scene.id }}';
    const saveBtn = document.getElementById('btn-image-save');
    const cancelBtn = document.getElementById('btn-image-cancel');
    const pending = window.__pendingGeneratedImage;

    if (!pending) return;

    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
    }
    if (cancelBtn) cancelBtn.disabled = true;

    try {
        const body = {};
        if (pending.candidate_filename) {
            body.candidate_filename = pending.candidate_filename;
        } else if (pending.source_path) {
            body.source_path = pending.source_path;
        } else {
            throw new Error('No candidate/source to save');
        }

        const res = await fetch(`/scene/${sceneId}/save_generated_image`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.success) {
            throw new Error(data.error || `HTTP ${res.status}`);
        }

        // UI„ÇíÊú¨Áï™ÁîªÂÉèË°®Á§∫„Å´Êàª„Åô
        const imageSection = document.querySelector('.image-section');
        const imageGallery = imageSection?.querySelector('.image-gallery');
        if (imageGallery) {
            const finalUrl = getCacheBustedUrl(data.image_url);
            imageGallery.innerHTML = `
                <div class="image-container">
                    <h4>üñºÔ∏è Image</h4>
                    <img src="${finalUrl}" alt="${data.filename || 'image'}" class="scene-image" onclick="window.open('${finalUrl}', '_blank')">
                </div>
            `;
        }

        try {
            if (window.__imageCompareSwiper && typeof window.__imageCompareSwiper.destroy === 'function') {
                window.__imageCompareSwiper.destroy(true, true);
            }
        } catch {}

        setPendingGeneratedImage(null);
        showSISGenerationProgress('üíæ Image saved (overwritten).', 'success');

    } catch (e) {
        console.error(e);
        showSISGenerationProgress(`‚ùå Failed to save image: ${e.message}`, 'error');
    } finally {
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.textContent = 'üíæ Save';
        }
        if (cancelBtn) cancelBtn.disabled = false;
    }
}

function restoreOriginalImageUI(originalUrl) {
    const imageSection = document.querySelector('.image-section');
    if (!imageSection) return;

    const imageGallery = imageSection.querySelector('.image-gallery');
    if (!imageGallery) return;

    try {
        if (window.__imageCompareSwiper && typeof window.__imageCompareSwiper.destroy === 'function') {
            window.__imageCompareSwiper.destroy(true, true);
        }
    } catch {}

    if (originalUrl) {
        const url = getCacheBustedUrl(originalUrl);
        imageGallery.innerHTML = `
            <div class="image-container">
                <h4>üñºÔ∏è Image</h4>
                <img src="${url}" alt="image" class="scene-image" onclick="window.open('${url}', '_blank')">
            </div>
        `;
    } else {
        imageGallery.innerHTML = `
            <div class="no-content">No image available. You can upload an image using the button above.</div>
        `;
    }
}

async function cancelGeneratedImage() {
    const sceneId = '{{ scene.id }}';
    const saveBtn = document.getElementById('btn-image-save');
    const cancelBtn = document.getElementById('btn-image-cancel');
    const pending = window.__pendingGeneratedImage;
    const originalUrl = getOriginalImageUrlForCompare();

    if (cancelBtn) {
        cancelBtn.disabled = true;
        cancelBtn.textContent = 'Cancelling...';
    }
    if (saveBtn) saveBtn.disabled = true;

    try {
        // SDÁõ¥ÁîüÊàê„ÅÆÂ†¥Âêà„ÅØÂÄôË£ú„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§
        if (pending?.candidate_filename) {
            await fetch(`/scene/${sceneId}/discard_generated_image`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ candidate_filename: pending.candidate_filename }),
            }).catch(() => {});
        }

        setPendingGeneratedImage(null);
        restoreOriginalImageUI(originalUrl);
        showSISGenerationProgress('‚ùå Cancelled. Original image kept.', 'success');
    } catch (e) {
        console.error(e);
        showSISGenerationProgress(`‚ùå Failed to cancel: ${e.message}`, 'error');
    } finally {
        if (cancelBtn) {
            cancelBtn.disabled = false;
            cancelBtn.textContent = '‚ùå Cancel';
        }
        if (saveBtn) saveBtn.disabled = false;
    }
}

// ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„ÅßÊó¢Â≠ò„ÅÆÁîªÂÉè„ÇíÁΩÆ„ÅçÊèõ„Åà„ÇãÈñ¢Êï∞
function overwriteOriginalImage(imageUrl, prompt) {
    console.log(`üîÑ Overwriting original image with: ${imageUrl}`);
    
    if (!confirm('Are you sure you want to replace the original image with the generated one? This action cannot be undone.')) {
        return;
    }
    
    // ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
    const sceneId = '{{ scene.id }}';
    
    // „Éú„Çø„É≥„ÇíÁÑ°ÂäπÂåñ
    const overwriteBtn = event.target;
    overwriteBtn.disabled = true;
    overwriteBtn.textContent = 'üîÑ Processing...';
    
    // ÁîªÂÉè„Çí„Éï„Çß„ÉÉ„ÉÅ„Åó„Å¶BlobÂΩ¢Âºè„ÅßÂèñÂæó
    fetch(imageUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.status}`);
            }
            return response.blob();
        })
        .then(blob => {
            // Blob„Çí„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Å´Â§âÊèõ
            const file = new File([blob], 'generated_image.png', { type: 'image/png' });
            
            // FormData„Çí‰ΩúÊàê„Åó„Å¶„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
            const formData = new FormData();
            formData.append('file', file);
            formData.append('overwrite', 'true');
            formData.append('prompt', prompt);
            
            return fetch(`/scene/${sceneId}/upload_image`, {
                method: 'POST',
                body: formData
            });
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('‚úÖ Image overwrite successful');
                
                // Êó¢Â≠ò„ÅÆÁîªÂÉè„ÇíÊñ∞„Åó„ÅÑÁîªÂÉè„Å´ÁΩÆ„ÅçÊèõ„Åà
                replaceExistingImageInUI(imageUrl, data.filename, prompt);
                
                // ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„Ç≥„É≥„ÉÜ„Éä„ÇíÂâäÈô§
                const generatedImageItem = document.querySelector('.generated-image-item');
                if (generatedImageItem) {
                    generatedImageItem.style.transition = 'opacity 0.5s ease';
                    generatedImageItem.style.opacity = '0';
                    setTimeout(() => {
                        generatedImageItem.remove();
                    }, 500);
                }
                
                // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏
                showOverwriteMessage('‚úÖ Image successfully replaced!', 'success');
                
            } else {
                throw new Error(data.error || 'Upload failed');
            }
        })
        .catch(error => {
            console.error('‚ùå Error overwriting image:', error);
            showOverwriteMessage(`‚ùå Failed to replace image: ${error.message}`, 'error');
        })
        .finally(() => {
            // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
            overwriteBtn.disabled = false;
            overwriteBtn.textContent = 'üîÑ Overwrite Image';
        });
}

// UI„ÅßÊó¢Â≠ò„ÅÆÁîªÂÉè„ÇíÁΩÆ„ÅçÊèõ„Åà„ÇãÈñ¢Êï∞
function replaceExistingImageInUI(newImageUrl, filename, prompt) {
    console.log(`üñºÔ∏è Replacing existing image in UI with: ${newImageUrl}`);
    
    // Êó¢Â≠ò„ÅÆÁîªÂÉè„Ç≥„É≥„ÉÜ„Éä„ÇíÊé¢„ÅôÔºàÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè‰ª•Â§ñÔºâ
    const imageContainers = document.querySelectorAll('.image-container:not(.generated-image-item)');
    
    if (imageContainers.length > 0) {
        // ÊúÄÂàù„ÅÆÊó¢Â≠òÁîªÂÉè„ÇíÁΩÆ„ÅçÊèõ„Åà
        const existingContainer = imageContainers[0];
        const existingImg = existingContainer.querySelector('.scene-image');
        const existingTitle = existingContainer.querySelector('h4');
        
        if (existingImg && existingTitle) {
            // ÁîªÂÉè„ÇΩ„Éº„Çπ„ÇíÊõ¥Êñ∞
            existingImg.src = newImageUrl;
            existingImg.alt = 'Generated Image (Replaced)';
            
            // „Çø„Ç§„Éà„É´„ÇíÊõ¥Êñ∞
            existingTitle.textContent = `üé® ${filename || 'Generated Image'}`;
            
            // ÁîªÂÉèÁõ¥‰∏ã„Å´„ÅØ„Éó„É≠„É≥„Éó„Éà„ÇÇ„Éï„É´„Çµ„Ç§„Ç∫„Éú„Çø„É≥„ÇÇË°®Á§∫„Åó„Å™„ÅÑ
            let imageInfo = existingContainer.querySelector('.image-info');
            if (imageInfo) {
                imageInfo.innerHTML = '';
            }
            
            // „Éè„Ç§„É©„Ç§„ÉàÂäπÊûú
            existingContainer.style.transition = 'all 0.5s ease';
            existingContainer.style.backgroundColor = '#e8f5e8';
            existingContainer.style.border = '2px solid #28a745';
            
            setTimeout(() => {
                existingContainer.style.backgroundColor = '';
                existingContainer.style.border = '';
            }, 3000);
            
            // „Çπ„É†„Éº„Ç∫„Çπ„ÇØ„É≠„Éº„É´
            existingContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }
}

// ÁΩÆ„ÅçÊèõ„Åà„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫Èñ¢Êï∞
function showOverwriteMessage(message, type = 'info') {
    let bgColor = '#17a2b8'; // info - blue
    
    if (type === 'success') {
        bgColor = '#28a745'; // green
    } else if (type === 'error') {
        bgColor = '#dc3545'; // red
    }
    
    // „É°„ÉÉ„Çª„Éº„Ç∏Div‰ΩúÊàê
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        background: ${bgColor};
        color: white;
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        text-align: center;
        font-weight: bold;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
        max-width: 400px;
        animation: slideInFromRight 0.5s ease-out;
    `;
    
    messageDiv.textContent = message;
    document.body.appendChild(messageDiv);
    
    // 3ÁßíÂæå„Å´ÂâäÈô§
    setTimeout(() => {
        messageDiv.style.animation = 'slideOutToRight 0.5s ease-out';
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
        }, 500);
    }, 3000);
}

// „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®„ÅÆCSS„ÇíÂãïÁöÑ„Å´ËøΩÂä†
if (!document.querySelector('#overwrite-animations')) {
    const style = document.createElement('style');
    style.id = 'overwrite-animations';
    style.textContent = `
        @keyframes slideInFromRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutToRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        .btn-warning {
            background-color: #ffc107;
            color: #212529;
            border-color: #ffc107;
        }
        
        .btn-warning:hover {
            background-color: #e0a800;
            border-color: #d39e00;
        }
    `;
    document.head.appendChild(style);
}

// ==== Scene-level Music Generation ====
async function generateSceneMusic() {
    // „Çª„Éº„ÉñÂá¶ÁêÜ‰∏≠„ÅØÂ∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÂÜçÂÆüË°åÔºà„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÁ≥ª„ÅÆÁ´∂Âêà„ÇíÈÅø„Åë„Çã„Åü„ÇÅ„ÅÆÁ∞°Êòì„Ç¨„Éº„ÉâÔºâ
    if (window.__musicPromptSaving) {
        showSISGenerationProgress('‚è≥ Saving prompt... please wait a moment.', 'info');
        setTimeout(() => generateSceneMusic(), 400);
        return;
    }
    const btn = document.getElementById('btn-generate-music');
    if (btn) { btn.disabled = true; btn.textContent = 'Generating...'; }
    const promptTa = document.getElementById('music-prompt-textarea');
    let prompt = (promptTa?.value || '').trim();
    if (!prompt || prompt === 'No music prompt available yet.') {
        showSISGenerationProgress('‚ùå Music prompt is empty. Edit or generate a prompt first.', 'error');
        if (btn) { btn.disabled = false; btn.textContent = 'Generate'; }
        return;
    }
    const musicSection = document.querySelector('.music-section');
    const overlay = showLoadingOverlay(musicSection, 'üéµ Generating music...');
    showSISGenerationProgress('üéµ Generating music...');
    try {
        const res = await fetch(`/scene/{{ scene.id }}/generate_music`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
        });
        let data = {};
        try { data = await res.json(); } catch { throw new Error('Invalid JSON response'); }
        if (!res.ok || !data.success) {
            throw new Error(data.error || `HTTP ${res.status}`);
        }
        displayGeneratedMusicCandidate(data.music_url, data.music_filename);
        showSISGenerationProgress('‚úÖ Music generation completed.', 'success');
        // Update prompt (backend saves it). Reload prompt file silently.
        loadMusicPromptFile('{{ scene.id }}', `music_{{ scene.id }}_prompt.txt`);
    } catch (e) {
        console.error('Music generation failed:', e);
        showSISGenerationProgress(`‚ùå Failed to generate music: ${e.message}`, 'error');
    } finally {
        hideLoadingOverlay(overlay);
        if (btn) { btn.disabled = false; btn.textContent = 'Generate'; }
    }
}

function setPendingGeneratedMusic(pending) {
    window.__pendingGeneratedMusic = pending || null;
    const btnSave = document.getElementById('btn-music-save');
    const btnCancel = document.getElementById('btn-music-cancel');
    const btnGenerate = document.getElementById('btn-generate-music');
    const hasPending = !!window.__pendingGeneratedMusic;
    if (btnSave) btnSave.style.display = hasPending ? '' : 'none';
    if (btnCancel) btnCancel.style.display = hasPending ? '' : 'none';
    if (btnGenerate) btnGenerate.disabled = hasPending;
}

function getOriginalMusicInfoForCompare() {
    const standard = `music_{{ scene.id }}.wav`;
    const players = Array.from(document.querySelectorAll('.music-section .music-controls .audio-player'));
    let filename = '';
    let url = '';

    const standardPlayer = players.find(p => (p.querySelector('.file-name')?.textContent || '').trim() === standard);
    const chosen = standardPlayer || players[0];
    if (chosen) {
        filename = (chosen.querySelector('.file-name')?.textContent || '').trim();
    }
    if (filename) {
        url = `/scene/{{ scene.id }}/file/${encodeURIComponent(filename)}`;
    }
    return { filename, url };
}

function buildAudioPlayerHtml(playerId, filename, url) {
    const safeName = filename || 'music.wav';
    const safeUrl = url || '';
    const onclick = safeUrl
        ? `togglePlayPause('${playerId}', '${safeUrl.replace(/'/g, "\\'")}')`
        : '';
    const disabledAttr = safeUrl ? '' : 'disabled';
    return `
        <div class="audio-player" id="${playerId}">
            <div class="player-controls">
                <button class="play-pause-btn" ${disabledAttr} onclick="${onclick}">
                    <span class="play-icon">‚ñ∂Ô∏è</span>
                    <span class="pause-icon" style="display:none;">‚è∏Ô∏è</span>
                </button>
                <span class="file-name">${safeName}</span>
                <div class="volume-control">
                    <span class="volume-icon">üéµ</span>
                    <input type="range" class="volume-slider" min="0" max="100" value="100" onchange="setVolume('${playerId}', this.value)">
                </div>
            </div>
            <div class="progress-container">
                <div class="time-display">
                    <span class="current-time">0:00</span>
                    <span class="duration">0:00</span>
                </div>
                <div class="progress-bar" onclick="seekAudio(event, '${playerId}')">
                    <div class="progress-fill"></div>
                    <div class="progress-handle"></div>
                </div>
            </div>
            <audio class="audio-element" preload="metadata"></audio>
        </div>
    `;
}

function showMusicCompareSwiper(originalInfo, candidateInfo) {
    const section = document.querySelector('.music-section');
    if (!section) return;
    let controlsWrapper = section.querySelector('.music-controls');
    if (!controlsWrapper) {
        // No music case: replace the "no-content" placeholder with a controls wrapper
        const noContent = section.querySelector('.no-content');
        if (noContent && !window.__musicNoContentOriginalHTML) {
            window.__musicNoContentOriginalHTML = noContent.outerHTML;
            const newDiv = document.createElement('div');
            newDiv.className = 'music-controls';
            noContent.replaceWith(newDiv);
            controlsWrapper = newDiv;
        } else {
            const newDiv = document.createElement('div');
            newDiv.className = 'music-controls';
            section.appendChild(newDiv);
            controlsWrapper = newDiv;
        }
    }

    // Save original DOM to restore on cancel/save
    if (!window.__musicControlsOriginalHTML) {
        window.__musicControlsOriginalHTML = controlsWrapper.innerHTML;
    }

    const swiperId = 'music-compare-swiper-{{ scene.id }}';
    controlsWrapper.innerHTML = `
        <div class="swiper music-compare-swiper" id="${swiperId}">
            <div class="swiper-wrapper">
                <div class="swiper-slide">
                    <h4>üéµ Original</h4>
                    ${buildAudioPlayerHtml('music-player-original-{{ scene.id }}', originalInfo.filename || 'No original music', originalInfo.url)}
                </div>
                <div class="swiper-slide">
                    <h4>üéµ Generated</h4>
                    ${buildAudioPlayerHtml('music-player-candidate-{{ scene.id }}', candidateInfo.filename || 'Generated music', candidateInfo.url)}
                </div>
            </div>
            <div class="swiper-pagination"></div>
        </div>
    `;

    if (typeof Swiper !== 'undefined') {
        window.__musicCompareSwiper = new Swiper(`#${swiperId}`, {
            loop: false,
            slidesPerView: 1,
            spaceBetween: 12,
            pagination: { el: `#${swiperId} .swiper-pagination`, clickable: true },
            initialSlide: 1
        });
    }
}

function restoreMusicControlsOriginal() {
    const section = document.querySelector('.music-section');
    if (!section) return;
    const controlsWrapper = section.querySelector('.music-controls');
    if (window.__musicNoContentOriginalHTML) {
        // Restore the original placeholder and remove the controls wrapper we created
        if (controlsWrapper) {
            const temp = document.createElement('div');
            temp.innerHTML = window.__musicNoContentOriginalHTML;
            const restored = temp.firstElementChild;
            if (restored) {
                controlsWrapper.replaceWith(restored);
            } else {
                controlsWrapper.remove();
            }
        }
    } else if (controlsWrapper) {
        controlsWrapper.innerHTML = window.__musicControlsOriginalHTML || controlsWrapper.innerHTML;
    }
    window.__musicControlsOriginalHTML = null;
    window.__musicNoContentOriginalHTML = null;
}

function displayGeneratedMusicCandidate(musicUrl, filename) {
    if (!musicUrl) return;
    const originalInfo = getOriginalMusicInfoForCompare();
    const candidateInfo = { filename: filename || 'music_candidate.wav', url: musicUrl };
    showMusicCompareSwiper(originalInfo, candidateInfo);
    setPendingGeneratedMusic({ candidateFilename: filename, candidateUrl: musicUrl });
}

async function saveGeneratedMusic() {
    const pending = window.__pendingGeneratedMusic;
    if (!pending) return;
    const btnSave = document.getElementById('btn-music-save');
    if (btnSave) { btnSave.disabled = true; btnSave.textContent = 'Saving...'; }
    try {
        const res = await fetch(`/scene/{{ scene.id }}/save_generated_music`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
        });
        let data = {};
        try { data = await res.json(); } catch { throw new Error('Invalid JSON response'); }
        if (!res.ok || !data.success) {
            throw new Error(data.error || `HTTP ${res.status}`);
        }

        // Restore original UI, then inject the final (saved) player
        restoreMusicControlsOriginal();
        setPendingGeneratedMusic(null);
        injectGeneratedMusicPlayer(data.music_url, data.music_filename);
        showSISGenerationProgress('‚úÖ Music saved.', 'success');
    } catch (e) {
        console.error('Save music failed:', e);
        showSISGenerationProgress(`‚ùå Failed to save music: ${e.message}`, 'error');
    } finally {
        if (btnSave) { btnSave.disabled = false; btnSave.textContent = 'üíæ Save'; }
    }
}

async function cancelGeneratedMusic() {
    const pending = window.__pendingGeneratedMusic;
    if (!pending) return;
    const btnCancel = document.getElementById('btn-music-cancel');
    if (btnCancel) { btnCancel.disabled = true; btnCancel.textContent = 'Cancelling...'; }
    try {
        const res = await fetch(`/scene/{{ scene.id }}/discard_generated_music`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
        });
        let data = {};
        try { data = await res.json(); } catch { throw new Error('Invalid JSON response'); }
        if (!res.ok || !data.success) {
            throw new Error(data.error || `HTTP ${res.status}`);
        }

        restoreMusicControlsOriginal();
        setPendingGeneratedMusic(null);
        showSISGenerationProgress('‚úÖ Discarded generated music.', 'info');
    } catch (e) {
        console.error('Discard music failed:', e);
        showSISGenerationProgress(`‚ùå Failed to discard: ${e.message}`, 'error');
    } finally {
        if (btnCancel) { btnCancel.disabled = false; btnCancel.textContent = '‚ùå Cancel'; }
    }
}

function injectGeneratedMusicPlayer(musicUrl, filename) {
    if (!musicUrl) return;
    const section = document.querySelector('.music-section');
    if (!section) return;
    let controlsWrapper = section.querySelector('.music-controls');
    if (!controlsWrapper) {
        controlsWrapper = document.createElement('div');
        controlsWrapper.className = 'music-controls';
        section.appendChild(controlsWrapper);
    }
    // Êó¢Â≠ò„Éó„É¨„Ç§„É§„Éº„ÅØ‰∏Ä„Å§„Å´Áµ±‰∏ÄÔºà„Ç∑„Éº„É≥Èü≥Ê•Ω„ÅØÂ∏∏„Å´1„Éï„Ç°„Ç§„É´ÈÅãÁî®„ÇíÊÉ≥ÂÆöÔºâ
    controlsWrapper.querySelectorAll('.audio-player').forEach(p => p.remove());
    const playerId = 'music-player-generated';
    const player = document.createElement('div');
    player.className = 'audio-player';
    player.id = playerId;
    player.innerHTML = `
        <div class="player-controls">
            <button class="play-pause-btn">
                <span class="play-icon">‚ñ∂Ô∏è</span>
                <span class="pause-icon" style="display:none;">‚è∏Ô∏è</span>
            </button>
            <span class="file-name"></span>
            <div class="volume-control">
                <span class="volume-icon">üéµ</span>
                <input type="range" class="volume-slider" min="0" max="100" value="100">
            </div>
        </div>
        <div class="progress-container">
            <div class="time-display">
                <span class="current-time">0:00</span>
                <span class="duration">0:00</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill"></div>
                <div class="progress-handle"></div>
            </div>
        </div>
        <audio class="audio-element" preload="metadata"></audio>
    `;
    controlsWrapper.appendChild(player);
    player.querySelector('.file-name').textContent = filename || 'music.wav';
    const btnPlay = player.querySelector('.play-pause-btn');
    btnPlay.onclick = () => togglePlayPause(playerId, musicUrl);
    const vol = player.querySelector('.volume-slider');
    vol.oninput = () => setVolume(playerId, vol.value);
    const pb = player.querySelector('.progress-bar');
    pb.onclick = (e) => seekAudio(e, playerId);
    // „Éè„Ç§„É©„Ç§„Éà
    player.style.border = '2px solid #28a745';
    player.style.backgroundColor = '#e8f5e8';
    setTimeout(() => { player.style.border = ''; player.style.backgroundColor = ''; }, 2000);
    player.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}
</script>
{% endblock %}
